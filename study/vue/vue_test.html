<!doctype html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="X-UA-Compatible" content="IE=edge, chrome=1">
    <meta name="viewport" content="width=device-width, user-scalable=no, maximum-scale=1.0, minimum-scale=1.0, initial-scale=1.0">
    <title>Vue test</title>

    <script type="text/javascript" src="../common/js/XRegExp.js"></script>
    <script type="text/javascript" src="../common/js/shCore.js"></script>
    <script type="text/javascript" src="../common/js/shBrushJScript.js"></script>
    <link type="text/css" rel="stylesheet" href="../common/css/shCore.css"/>
    <link type="text/css" rel="Stylesheet" href="../common/css/shThemeDefault.css" />
    <script type="text/javascript">SyntaxHighlighter.all();</script>

    <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
    <style>
        body > div {margin-bottom:100px;}

        .syntaxhighlighter {margin:10px 0 0 0 !important;}
		.syntaxhighlighter .line {line-height: 24px !important;font-size: 14px !important;}
		.syntaxhighlighter table td.gutter .line {padding: 0 0.5em 0 0.5em !important;}

        @media (min-width:1024px) {
            body {width:1024px;margin:0 auto;}
			.syntaxhighlighter {max-height:25vw; overflow-y:scroll;}
			.syntaxhighlighter .line {line-height: 18px !important;}
		}
		@media (max-width:768px) {
			body {margin:10vw 4vw;}
			.syntaxhighlighter {max-height:92vw; overflow-y:scroll;}
			.syntaxhighlighter table td.gutter .line {padding: 0 5px !important;}
			.syntaxhighlighter .line {line-height: 24px !important;padding: 0 10px !important;}
		}
    </style>
</head>
<body>
    <h1>01.Vue 시작하기</h1>
    <div>
        <div id="app">
            {{ msg }}
        </div>
        <script>
            const vm = new Vue({
                el: '#app',
                data: {
                    msg: 'Hello Vue!!'
                }
            });
        </script>
        <script type="syntaxhighlighter" class="brush: js;">
            <![CDATA[
                const vm = new Vue({
                    el: '#app',
                    data: {
                        msg: 'Hello Vue!!'
                    }
                });         
            ]]>
        </script>
    </div>

    <h2>01.선언적 렌더링</h2>
    <div>    
        <div id="app01_01">
            <div class="text" v-bind:class="{ 'on': active }"><!-- active 값이 true일때 추가 -->
                {{ message }}
            </div>
        </div>
        <style>
            .text {font-size:40px;}
            .text.on {color:red;}
        </style>
        <script>
            const vm01_01 = new Vue({
                el:'#app01_01',
                data:{
                    message:'Hello Vue!',
                    active: true
                }
            })
        </script>
        <script type="syntaxhighlighter" class="brush: js;">
            <![CDATA[
                <div class="text" v-bind:class="{ 'on': active }"><!-- active 값이 true일때 추가 -->
                    {{ message }}
                </div> 
                
                const vm01_01 = new Vue({
                    el:'#app01_01',
                    data:{
                        message:'Hello Vue!',
                        active: true
                    }
                })   
            ]]>
        </script>
    </div>

    <h2>02.조건문과 반복문</h2>
    <div>
        <div id="app01_02">
            <div v-if="message">
                {{ message }}
            </div>
            <ul>
                <li v-for="item in items"
                    v-bind:key="item.id"><!-- v-for 디렉티브를 사용할 때는 무조건 v-bind:key=""를 추가  -->
                    {{ item.message }}
                </li>
            </ul>
        </div>
        <script>
            const vm01_02 = new Vue({
                el:'#app01_02',
                data:{
                    show:true,
                    message:'Hello World', // 빈문자, 0은 false
                    items:[
                        {id:'1', message:'Hello World'},
                        {id:'2', message:'Good job!'},
                        {id:'3', message:'My first Vue app'}
                    ]
                }
            })
        </script>
        <script type="syntaxhighlighter" class="brush: js;">
            <![CDATA[
                <div v-if="message">
                    {{ message }}
                </div>
                <ul>
                    <li v-for="item in items"
                        v-bind:key="item.id"><!-- v-for 디렉티브를 사용할 때는 무조건 v-bind:key=""를 추가  -->
                        {{ item.message }}
                    </li>
                </ul>
                
                const vm01_02 = new Vue({
                    el:'#app01_02',
                    data:{
                        show:true,
                        message:'Hello World', // 빈문자, 0은 false
                        items:[
                            {id:'1', message:'Hello World'},
                            {id:'2', message:'Good job!'},
                            {id:'3', message:'My first Vue app'}
                        ]
                    }
                })
            ]]>
        </script>
    </div>

    <h2>03.사용자 입력 핸들링</h2>
    <div>
        <div id="app01_03">
            <div class="box"
                v-bind:class="{ 'active':toggle }"
                v-on:click="toggleElement">
                {{ message }}
            </div>
            <button type="button" v-on:click="toggleElement">Toggle</button>
            <input type="text" v-model="message" />
        </div>
        <style>
            #app01_03 .box {
              width:150px;
              height:150px;
              background:royalblue;
              border-radius:10px;
              cursor:pointer;
              transition:1s;
              color:white;
              display:flex;
              justify-content:center;
              align-items:center;
            }
            #app01_03 .box.active {
              width:300px;
              background:tomato;
            }
        </style>
        <script>
            const vm01_03 = new Vue({
              el:'#app01_03',
              data:{
                toggle:false,
                message:''
              },
              methods:{
                toggleElement() {
                  this.toggle = !this.toggle
                }
              }
            })
        </script>
        <script type="syntaxhighlighter" class="brush: js;">
            <![CDATA[
                <div class="box"
                    v-bind:class="{ 'active':toggle }"
                    v-on:click="toggleElement">
                    {{ message }}
                </div>
                <button type="button" v-on:click="toggleElement">Toggle</button>
                <input type="text" v-model="message" />        

                const vm01_03 = new Vue({
                    el:'#app01_03',
                    data:{
                      toggle:false,
                      message:''
                    },
                    methods:{
                      toggleElement() {
                        this.toggle = !this.toggle
                      }
                    }
                  })
            ]]>
        </script>
    </div>
    
    <h2>05.컴포넌트를 사용한 작성방법</h2>
    <div>
        <div id="app01_05">
            <ul>
                <!--
                <li v-for="todo in todos"
                    v-bind:key="todo.id">
                    <input type="checkbox" 
                           v-model="todo.done" />
                    <span v-bind:class="{ done: todo.done }">{{ todo.title }}</span>
                </li>
                -->
                <my-todo-item v-for="todo in todos"
                              v-bind:key="todo.id"
                              v-bind:todo="todo">
                </my-todo-item>
            </ul>
            <ul>
                <my-todo-item v-for="todo in todos2"
                              v-bind:key="todo.id"
                              v-bind:todo="todo">
                </my-todo-item>
            </ul>
        </div>
        <style>
            #app01_05 li span.done {text-decoration: line-through;} 
        </style>
        <script>
            // template로 반복 사용을 하기 때문에 v-for, v-bind는 필요하지 않다
            Vue.component('my-todo-item',{
                props:['todo'], // 외부에서 todo라는 이름으로 특정한 값을 받아서 사용함을 선언
                template: `
                    <li><input type="checkbox" v-model="todo.done" />
                        <span v-bind:class="{ done: todo.done }">{{ todo.title }}</span>
                    </li>`
                
            })
            const vm01_05 = new Vue({
                el:'#app01_05',
                data:{
                    todos:[
                        {
                            id:'1',
                            title:'아침 먹기',
                            done:true
                        },
                        {
                            id:'2',
                            title:'점심 먹기',
                            done:false
                        },
                        {
                            id:'3',
                            title:'저녁 먹기',
                            done:true
                        },
                        {
                            id:'4',
                            title:'간식 먹기',
                            done:false
                        },
                        {
                            id:'5',
                            title:'야식 먹기',
                            done:false
                        }
                    ],
                    todos2:[
                        {
                            id:'6',
                            title:'잠자기',
                            done:true
                        }
                    ]
                }
            })
        </script>
        <script type="syntaxhighlighter" class="brush: js;">
            <![CDATA[
                <ul>
                    <!--
                    <li v-for="todo in todos"
                        v-bind:key="todo.id">
                        <input type="checkbox" 
                            v-model="todo.done" />
                        <span v-bind:class="{ done: todo.done }">{{ todo.title }}</span>
                    </li>
                    -->
                    <my-todo-item v-for="todo in todos"
                                v-bind:key="todo.id"
                                v-bind:todo="todo">
                    </my-todo-item>
                </ul>
                <ul>
                    <my-todo-item v-for="todo in todos2"
                                v-bind:key="todo.id"
                                v-bind:todo="todo">
                    </my-todo-item>
                </ul>

                // template로 반복 사용을 하기 때문에 v-for, v-bind는 필요하지 않다
                Vue.component('my-todo-item',{
                    props:['todo'], // 외부에서 todo라는 이름으로 특정한 값을 받아서 사용함을 선언
                    template: `
                        <li><input type="checkbox" v-model="todo.done" />
                            <span v-bind:class="{ done: todo.done }">{{ todo.title }}</span>
                        </li>`
                    
                })
                const vm01_05 = new Vue({
                    el:'#app01_05',
                    data:{
                        todos:[
                            {
                                id:'1',
                                title:'아침 먹기',
                                done:true
                            },
                            {
                                id:'2',
                                title:'점심 먹기',
                                done:false
                            },
                            {
                                id:'3',
                                title:'저녁 먹기',
                                done:true
                            },
                            {
                                id:'4',
                                title:'간식 먹기',
                                done:false
                            },
                            {
                                id:'5',
                                title:'야식 먹기',
                                done:false
                            }
                        ],
                        todos2:[
                            {
                                id:'6',
                                title:'잠자기',
                                done:true
                            }
                        ]
                    }
                })
            ]]>
        </script>
    </div>
    
    <h1>02.Vue 가이드 문서 따라가기</h1>
    <h2>01.Vue 인스턴스</h2>
    <div>
        <div id="app02_01">
            <div>{{ msgA }}</div>
            <div>{{ msgB }}</div>
            <button type="button" v-on:click="changeMessage">Change!</button>
        </div>
        
        <style></style>
        <script>
            const vm02_01 = new Vue({
                el:'#app02_01',
                data:{
                    msgA:'message A.',
                    msgB:'' // vue 인스턴스 생성시 선언되지 않으면 값을 변경할 수 있지만 반응성이 없다. 빈 데이터라도 선언을 해야 반응성으로 사용 가능
                },
                methods:{
                    changeMessage(){
                        this.msgA = 'Change message A!'
                        this.msgB = 'Change message B!'
                    }
                },
                computed:{},
                watch:{ // 데이터 반응성이 일어 날때마다 실행
                    msgA(value){
                        console.log(value);
                    }
                },
                created(){
                    
                },
                mounted(){
                    
                }
            })
        </script>
        <script type="syntaxhighlighter" class="brush: js;">
            <![CDATA[
                <div>{{ msgA }}</div>
                <div>{{ msgB }}</div>
                <button type="button" v-on:click="changeMessage">Change!</button>      

                const vm02_01 = new Vue({
                    el:'#app02_01',
                    data:{
                        msgA:'message A.',
                        msgB:'' // vue 인스턴스 생성시 선언되지 않으면 값을 변경할 수 있지만 반응성이 없다. 빈 데이터라도 선언을 해야 반응성으로 사용 가능
                    },
                    methods:{
                        changeMessage(){
                            this.msgA = 'Change message A!'
                            this.msgB = 'Change message B!'
                        }
                    },
                    computed:{},
                    watch:{ // 데이터 반응성이 일어 날때마다 실행
                        msgA(value){
                            console.log(value);
                        }
                    },
                    created(){
                        
                    },
                    mounted(){
                        
                    }
                })
            ]]>
        </script>
    </div>
    
    <h2>02.라이프 사이클 - 2</h2>
    <div>
        <div id="app02_02">
            <div ref="msg">{{ msg }}</div>
            <div ref="div"></div><!-- div라는 이름으로 이 요소를 참조 함을 선언 -->
        </div>
        <style></style>
        <script>
            const vm02_02 = new Vue({
                el:'#app02_02',
                data:{
                    msg:'Hello Vue!'
                },
                //beforeCreate(){   es6
                beforeCreate:function(){
                    // 인스턴스가 생성되기 전 시점, msg의 값을 알 수 없다.
                    console.log('beforeCreate!', this.msg) // undefined
                },
                created(){
                    console.log('created!', this.msg) // Hello Vue!
                },
                beforeMount(){
                    // html과 vue가 연결되지 전 시점, $refs.div의 값을 알 수 없다. 
                    console.log('beforeMount!', this.$refs.div) // undefined
                },
                mounted(){
                    console.log('mounted!', this.$refs.div) // <div></div>
                },
                beforeUpdate(){
                    // vm02_02.msg = "qwe"
                    // data 변경 직전 시 실행
                    console.log('beforeUpdate!', this.$refs.msg.innerText)
                },
                updated(){
                    // data 변경되고 화면이 다시 그려진 후 실행
                    console.log('updated!', this.$refs.msg.innerText)
                },
                beforeDestroy(){
                    // vm02_02.$destroy() 인스턴스 파괴되어 반응성이 사라짐
                    console.log('beforeDestroy!')
                },
                destroyed(){
                    console.log('destroyed!')
                }
            })
        </script>
        <script type="syntaxhighlighter" class="brush: js;">
            <![CDATA[
                <div ref="msg">{{ msg }}</div>
                <div ref="div"></div><!-- div라는 이름으로 이 요소를 참조 함을 선언 -->

                const vm02_02 = new Vue({
                    el:'#app02_02',
                    data:{
                        msg:'Hello Vue!'
                    },
                    //beforeCreate(){   es6
                    beforeCreate:function(){
                        // 인스턴스가 생성되기 전 시점, msg의 값을 알 수 없다.
                        console.log('beforeCreate!', this.msg) // undefined
                    },
                    created(){
                        console.log('created!', this.msg) // Hello Vue!
                    },
                    beforeMount(){
                        // html과 vue가 연결되지 전 시점, $refs.div의 값을 알 수 없다. 
                        console.log('beforeMount!', this.$refs.div) // undefined
                    },
                    mounted(){
                        console.log('mounted!', this.$refs.div) // <div></div>
                    },
                    beforeUpdate(){
                        // vm02_02.msg = "qwe"
                        // data 변경 직전 시 실행
                        console.log('beforeUpdate!', this.$refs.msg.innerText)
                    },
                    updated(){
                        // data 변경되고 화면이 다시 그려진 후 실행
                        console.log('updated!', this.$refs.msg.innerText)
                    },
                    beforeDestroy(){
                        // vm02_02.$destroy() 인스턴스 파괴되어 반응성이 사라짐
                        console.log('beforeDestroy!')
                    },
                    destroyed(){
                        console.log('destroyed!')
                    }
                })
            ]]>
        </script>
    </div>
    
    <h2>04.템플릿 문법</h2>
    <div>
        <div id="app02_04">
            <div v-once>{{ msg }}</div> <!-- 렌더링 후 반응성 사용하지 않음 -->
            <div>{{ msg }}</div>        <!-- html tag를 문자 그대로 출력 -->
            <div v-html="msg"></div>    <!-- html tag를 삽입 시 사용 -->
            <div>{{ number + 2 }}</div> <!-- js 표현식 사용 가능 -->
            <div>{{ new Date() }}</div>
            <div>{{ Math.round(2.7) }}</div>
            
            <br>
            
            <div v-bind:class="className"
                 v-on:click="changeClassName">
                {{ msg2 }}
            </div>
            <!-- v-bind, v-on 약어 -->
            <div :class="className"
                 @click="changeClassName">
                {{ msg2 }}
            </div>  
        </div>
        <style>
            .normal {color:blue;}
            .active {color:red;}
        </style>
        <script>
            const vm02_04 = new Vue({
                el:'#app02_04',
                data:{
                    msg:'Hello Vue!<br>Good job~',
                    msg2:'Hello Vue!',
                    number:2,
                    className:'normal'
                },
                methods:{
                    changeClassName(){
                        this.className = 'active'
                    }
                }
                
            })
        </script>
        <script type="syntaxhighlighter" class="brush: js;">
            <![CDATA[
                <div v-once>{{ msg }}</div> <!-- 렌더링 후 반응성 사용하지 않음 -->
                <div>{{ msg }}</div>        <!-- html tag를 문자 그대로 출력 -->
                <div v-html="msg"></div>    <!-- html tag를 삽입 시 사용 -->
                <div>{{ number + 2 }}</div> <!-- js 표현식 사용 가능 -->
                <div>{{ new Date() }}</div>
                <div>{{ Math.round(2.7) }}</div>
                
                <br>
                
                <div v-bind:class="className"
                    v-on:click="changeClassName">
                    {{ msg2 }}
                </div>
                <!-- v-bind, v-on 약어 -->
                <div :class="className"
                    @click="changeClassName">
                    {{ msg2 }}
                </div>

                const vm02_04 = new Vue({
                    el:'#app02_04',
                    data:{
                        msg:'Hello Vue!<br>Good job~',
                        msg2:'Hello Vue!',
                        number:2,
                        className:'normal'
                    },
                    methods:{
                        changeClassName(){
                            this.className = 'active'
                        }
                    }
                    
                })
            ]]>
        </script>
    </div>
    
    <h2>05.computed</h2>
    <div>
        <div id="app02_05">
            <div class="todos">
                <div v-for="todo in computedTodos"
                     :key="todo.id">
                    <input type="checkbox"
                           v-model="todo.done" />
                    <span>{{ todo.title }}</span>
                </div>
            </div>
        </div>
        <style></style>
        <script>
            const vm02_05 = new Vue({
                el:'#app02_05',
                data:{
                    todos:[
                        {title:'아침 먹기'},
                        {title:'점심 먹기'},
                        {title:'저녁 먹기'}
                    ]
                },
                computed:{
                    computedTodos(){
                    // 반복문 사용 시 서버에서 받아 온 data에 id 값이 없는 경우처럼 data를 가공 할 경우
                       return this.todos.map( (todo, index) => {
                           /*
                           return Object.assign({}, todo, {
                               id: index + 1,
                               done: false
                           })
                           */
                           return {
                               ...todo, // es6 spread
                               id: index + 1,
                               done: false
                           }
                       })
                    }
                }
                // vm02_05.todos의 값은 변경되지 않고 vm02_05.computedTodos의 값은 재가공 되었다.
                // vm02_05.todos.push({ id:4, done:false, title:'야식 먹기' }) todos를 변경하면 computedTodos도 변경 된다.
                // * es6 spread
                // var obj1 = { foo: 'bar', x: 42 };
                // var clonedObj = { ...obj1 };
                // Object { foo: "bar", x: 42 }
            })
        </script>
        <script type="syntaxhighlighter" class="brush: js;">
            <![CDATA[
                <div class="todos">
                    <div v-for="todo in computedTodos"
                        :key="todo.id">
                        <input type="checkbox"
                            v-model="todo.done" />
                        <span>{{ todo.title }}</span>
                    </div>
                </div>  
                
                const vm02_05 = new Vue({
                    el:'#app02_05',
                    data:{
                        todos:[
                            {title:'아침 먹기'},
                            {title:'점심 먹기'},
                            {title:'저녁 먹기'}
                        ]
                    },
                    computed:{
                        computedTodos(){
                        // 반복문 사용 시 서버에서 받아 온 data에 id 값이 없는 경우처럼 data를 가공 할 경우
                           return this.todos.map( (todo, index) => {
                               /*
                               return Object.assign({}, todo, {
                                   id: index + 1,
                                   done: false
                               })
                               */
                               return {
                                   ...todo, // es6 spread
                                   id: index + 1,
                                   done: false
                               }
                           })
                        }
                    }
                    // vm02_05.todos의 값은 변경되지 않고 vm02_05.computedTodos의 값은 재가공 되었다.
                    // vm02_05.todos.push({ id:4, done:false, title:'야식 먹기' }) todos를 변경하면 computedTodos도 변경 된다.
                    // * es6 spread
                    // var obj1 = { foo: 'bar', x: 42 };
                    // var clonedObj = { ...obj1 };
                    // Object { foo: "bar", x: 42 }
                })
            ]]>
        </script>
    </div>
    
    <h2>06.computed 캐싱</h2>
    <div>
        <div id="app02_06">
            <div>{{ msg }}</div>
            <div>{{ msg.split('').reverse().join('') }}</div>   <!-- 표현식 그대로 사용 -->
            <div>{{ reverseMsg() }}</div>                       <!-- method 함수 호출 -->
            <div>------------------</div>
            <div>{{ reversedMsg }}</div>                        <!-- 함수가 아니고 데이터처럼 사용하기 때문에 () 없음 -->
            <div>{{ reversedMsg }}</div>                        <!-- computed의 경우 연산 결과 값을 캐싱(저장)하기 때문에 동일한 연산의 경우에는 연산 없이 출력한다. 총 연산은 1회 -->
            <div>{{ reversedMsg }}</div>
        </div>
        <style></style>
        <script>
            const vm02_06 = new Vue({
                el:'#app02_06',
                data:{
                    msg:'Hello Vue!'
                },
                computed:{
                    reversedMsg(){
                        return this.msg.split('').reverse().join('')
                    }
                },
                methods:{
                    reverseMsg(){
                        return this.msg.split('').reverse().join('')
                    }
                }
            })
        </script>
        <script type="syntaxhighlighter" class="brush: js;">
            <![CDATA[
                <div>{{ msg }}</div>
                <div>{{ msg.split('').reverse().join('') }}</div>   <!-- 표현식 그대로 사용 -->
                <div>{{ reverseMsg() }}</div>                       <!-- method 함수 호출 -->
                <div>------------------</div>
                <div>{{ reversedMsg }}</div>                        <!-- 함수가 아니고 데이터처럼 사용하기 때문에 () 없음 -->
                <div>{{ reversedMsg }}</div>                        <!-- computed의 경우 연산 결과 값을 캐싱(저장)하기 때문에 동일한 연산의 경우에는 연산 없이 출력한다. 총 연산은 1회 -->
                <div>{{ reversedMsg }}</div>

                const vm02_06 = new Vue({
                    el:'#app02_06',
                    data:{
                        msg:'Hello Vue!'
                    },
                    computed:{
                        reversedMsg(){
                            return this.msg.split('').reverse().join('')
                        }
                    },
                    methods:{
                        reverseMsg(){
                            return this.msg.split('').reverse().join('')
                        }
                    }
                })
            ]]>
        </script>
    </div>
    
    <h2>07.computed의 Getter, Setter</h2>
    <div>
        <div id="app02_07">{{ reversedMsg }}</div>
        <style></style>
        <script>
            const vm02_07 = new Vue({
                el:'#app02_07',
                data:{
                    msg:'Hello Vue!'
                },
                computed:{
                    reversedMsg:{
                        // return this.msg.split('').reverse().join('')
                        
                        // getter : data setting 불가 vm02_07.reversedMsg = "Good job~"
                        // 무조건 return 필요
                        //get:function(){
                        get(){
                            return this.msg.split('').reverse().join('')
                        },
                        set(value){
                            // vm02_07.reversedMsg = "Good job~"
                            // 값을 할당 받았을때 처리
                            this.msg = value;
                        }
                    }
                }
            })
        </script>
        <script type="syntaxhighlighter" class="brush: js;">
            <![CDATA[
                <div id="app02_07">{{ reversedMsg }}</div>       

                const vm02_07 = new Vue({
                    el:'#app02_07',
                    data:{
                        msg:'Hello Vue!'
                    },
                    computed:{
                        reversedMsg:{
                            // return this.msg.split('').reverse().join('')
                            
                            // getter : data setting 불가 vm02_07.reversedMsg = "Good job~"
                            // 무조건 return 필요
                            //get:function(){
                            get(){
                                return this.msg.split('').reverse().join('')
                            },
                            set(value){
                                // vm02_07.reversedMsg = "Good job~"
                                // 값을 할당 받았을때 처리
                                this.msg = value;
                            }
                        }
                    }
                })
            ]]>
        </script>
    </div>
    
    <h2>08.watch</h2>
    <div>
        <div id="app02_08">
            <div>{{ msg }}</div>
            <div>{{ reversedMsg }}</div>
        </div>
        <style></style>
        <script>
            const vm02_08 = new Vue({
                el:'#app02_08',
                data:{
                    msg:'Hello Vue!'
                },
                computed:{
                    reversedMsg:{
                        // return this.msg.split('').reverse().join('')
                        get(){
                          return this.msg.split('').reverse().join('')  
                        },
                        set(v){
                            this.msg = v
                        }
                    }
                    // vm02_08.reversedMsg = "Good job~"
                    // New msg: Good job~
                    // New reversedMsg: ~boj dooG
                },
                watch:{
                    // 데이터(일반, 계산된)가 변경됨을 감지하고 이후 로직 수행 가능
                    // 비동기 처리에도 유리하게 사용할 수 있다.
                    msg(newMsg){
                        console.log('New msg: ' + newMsg)
                        // vm02_08.msg = "Good job~"
                        // New msg: Good job~
                    },
                    reversedMsg(newMsg){
                        console.log('New reversedMsg: ' + newMsg)
                    }
                }
            })
        </script>
        <script type="syntaxhighlighter" class="brush: js;">
            <![CDATA[
                <div>{{ msg }}</div>
                <div>{{ reversedMsg }}</div>

                const vm02_08 = new Vue({
                    el:'#app02_08',
                    data:{
                        msg:'Hello Vue!'
                    },
                    computed:{
                        reversedMsg:{
                            // return this.msg.split('').reverse().join('')
                            get(){
                              return this.msg.split('').reverse().join('')  
                            },
                            set(v){
                                this.msg = v
                            }
                        }
                        // vm02_08.reversedMsg = "Good job~"
                        // New msg: Good job~
                        // New reversedMsg: ~boj dooG
                    },
                    watch:{
                        // 데이터(일반, 계산된)가 변경됨을 감지하고 이후 로직 수행 가능
                        // 비동기 처리에도 유리하게 사용할 수 있다.
                        msg(newMsg){
                            console.log('New msg: ' + newMsg)
                            // vm02_08.msg = "Good job~"
                            // New msg: Good job~
                        },
                        reversedMsg(newMsg){
                            console.log('New reversedMsg: ' + newMsg)
                        }
                    }
                })
            ]]>
        </script>
    </div>
    
    <h2>09.클래스와 스타일 바인딩 - 1</h2>
    <div>
        <!-- 
            <div v-bind:class="{ active: isActive }"></div> 클래스 active는 데이터 속성 isActive 의 참 속성에 의해 결정

            * v-bind:class 디렉티브는 일반 class 속성과 공존할 수 있다
            <div 
                class="static"
                v-bind:class="{ active: isActive, 'text-danger': hasError }"
            ></div>
            data: {
                isActive: true,
                hasError: false
            }
            랜더링 결과           <div class="static active"></div>
            hasError:true 일 경우 <div class="static active text-danger"></div>



            *바인딩 된 객체
            <div v-bind:class="classObject"></div>

            data: {
                classObject: {
                    active: true,
                    'text-danger': false
                }
            }



            * 객체를 반환하는 계산된 속성에도 바인딩 할 수 있다
            <div v-bind:class="classObject"></div>
            data: {
                isActive: true,
                error: null
            },
            computed: {
                classObject: function () {
                    return {
                        active: this.isActive && !this.error,
                        'text-danger': this.error && this.error.type === 'fatal'
                    }
                }
            }




            * 배열을 v-bind:class 에 전달하여 클래스 목록을 지정할 수 있다
            <div v-bind:class="[activeClass, errorClass]"></div>
            data: {
                activeClass: 'active',
                errorClass: 'text-danger'
            }
            랜더링 결과 <div class="active text-danger"></div>

            삼항연산자
            <div v-bind:class="[isActive ? activeClass : '', errorClass]"></div>
            
            여러 조건부 클래스가 있는 경우 장황해질 수 있어서 배열 구문 내에서 객체 구문을 사용할 수 있다.
            <div v-bind:class="[{ active: isActive }, errorClass]"></div>

            

            * 컴포넌트와 함께 사용
            Vue.component('my-component', {
                template: '<p class="foo bar">Hi</p>'
            })
            <my-component class="baz boo"></my-component>
            랜더링 결과 <p class="foo bar baz boo">Hi</p>

            클래스 바인딩
            <my-component v-bind:class="{ active: isActive }"></my-component>
            isActive가 참일 경우 <p class="foo bar active">Hi</p>


            
            * 인라인 스타일 바인딩
            v-bind:style 객체 구문은 CSS 처럼 보이지만 JavaScript 객체여서 속성에 camelCase와 kebab-case(따옴표를 함께 사용)를 사용할 수 있다.
            <div v-bind:style="{ color: activeColor, fontSize: fontSize + 'px' }"></div>
            <div v-bind:style="{ color: activeColor, 'font-size': fontSize + 'px' }"></div>
            data: {
                activeColor: 'red',
                fontSize: 30
            }

            스타일 객체에 직접 바인딩 하여 템플릿이 더 간결하게 할수 있다.
            <div v-bind:style="styleObject"></div>
            data: {
                styleObject: {
                    color: 'red',
                    fontSize: '13px'
                }
            }


            v-bind:style에 대한 배열 구문은 같은 스타일의 엘리먼트에 여러 개의 스타일 객체를 사용할 수 있다.
            <div v-bind:style="[baseStyles, overridingStyles]"></div>
        -->
        <style></style>
        <script></script>
        <script type="syntaxhighlighter" class="brush: js;">
            <![CDATA[
                <div v-bind:class="{ active: isActive }"></div> 클래스 active는 데이터 속성 isActive 의 참 속성에 의해 결정

                * v-bind:class 디렉티브는 일반 class 속성과 공존할 수 있다
                <div 
                    class="static"
                    v-bind:class="{ active: isActive, 'text-danger': hasError }"
                ></div>
                data: {
                    isActive: true,
                    hasError: false
                }
                랜더링 결과           <div class="static active"></div>
                hasError:true 일 경우 <div class="static active text-danger"></div>



                *바인딩 된 객체
                <div v-bind:class="classObject"></div>

                data: {
                    classObject: {
                        active: true,
                        'text-danger': false
                    }
                }



                * 객체를 반환하는 계산된 속성에도 바인딩 할 수 있다
                <div v-bind:class="classObject"></div>
                data: {
                    isActive: true,
                    error: null
                },
                computed: {
                    classObject: function () {
                        return {
                            active: this.isActive && !this.error,
                            'text-danger': this.error && this.error.type === 'fatal'
                        }
                    }
                }




                * 배열을 v-bind:class 에 전달하여 클래스 목록을 지정할 수 있다
                <div v-bind:class="[activeClass, errorClass]"></div>
                data: {
                    activeClass: 'active',
                    errorClass: 'text-danger'
                }
                랜더링 결과 <div class="active text-danger"></div>

                삼항연산자
                <div v-bind:class="[isActive ? activeClass : '', errorClass]"></div>
                
                여러 조건부 클래스가 있는 경우 장황해질 수 있어서 배열 구문 내에서 객체 구문을 사용할 수 있다.
                <div v-bind:class="[{ active: isActive }, errorClass]"></div>

                

                * 컴포넌트와 함께 사용
                Vue.component('my-component', {
                    template: '<p class="foo bar">Hi</p>'
                })
                <my-component class="baz boo"></my-component>
                랜더링 결과 <p class="foo bar baz boo">Hi</p>

                클래스 바인딩
                <my-component v-bind:class="{ active: isActive }"></my-component>
                isActive가 참일 경우 <p class="foo bar active">Hi</p>


                
                * 인라인 스타일 바인딩
                v-bind:style 객체 구문은 CSS 처럼 보이지만 JavaScript 객체여서 속성에 camelCase와 kebab-case(따옴표를 함께 사용)를 사용할 수 있다.
                <div v-bind:style="{ color: activeColor, fontSize: fontSize + 'px' }"></div>
                <div v-bind:style="{ color: activeColor, 'font-size': fontSize + 'px' }"></div>
                data: {
                    activeColor: 'red',
                    fontSize: 30
                }

                스타일 객체에 직접 바인딩 하여 템플릿이 더 간결하게 할수 있다.
                <div v-bind:style="styleObject"></div>
                data: {
                    styleObject: {
                        color: 'red',
                        fontSize: '13px'
                    }
                }


                v-bind:style에 대한 배열 구문은 같은 스타일의 엘리먼트에 여러 개의 스타일 객체를 사용할 수 있다.
                <div v-bind:style="[baseStyles, overridingStyles]"></div>    
            ]]>
        </script>
    </div>
    
    <h2>11.조건부 렌더링 - v-if</h2>
    <div>
        <!-- 형제요소인 경우에 사용 -->
        <div id="app02_11">
            <div v-if="colorState === 'red'" 
                 class="box box-red"></div>
            <div v-else-if="colorState === 'blue'"
                 class="box box-blue"
                 ></div>
            <div v-else
                 class="box box-gray"></div>
        </div>
        <style>
            #app02_11 .box {width:100px;height:100px;}
            #app02_11 .box-red {background: red;}
            #app02_11 .box-blue {background: blue;}
            #app02_11 .box-gray {background: gray;}
        </style>
        <script>
            const vm02_11 = new Vue({
                el:'#app02_11',
                data:{
                    colorState:'blue'
                }
            })
        </script>
        <script type="syntaxhighlighter" class="brush: js;">
            <![CDATA[
                <!-- 형제요소인 경우에 사용 -->
                <div id="app02_11">
                    <div v-if="colorState === 'red'" 
                        class="box box-red"></div>
                    <div v-else-if="colorState === 'blue'"
                        class="box box-blue"
                        ></div>
                    <div v-else
                        class="box box-gray"></div>
                </div>

                const vm02_11 = new Vue({
                    el:'#app02_11',
                    data:{
                        colorState:'blue'
                    }
                })
            ]]>
        </script>
    </div>
    
    <h2>12.조건부 렌더링 - v-show</h2>
    <div>
        <!-- v-if : html tag를 생성, 제거
             v-show : css style로 제어 (display:none)
        -->
        <div id="app02_12">
            <button @click="toggle" type="button">Toggle</button>
            <div>
                <span v-if="show"
                     class="box"></span>
                <span v-show="show"
                     class="box"></span>
            </div>
        </div>
        <style>
            #app02_12 .box {display:inline-block;width:150px;height:150px;background: red;}
        </style>
        <script>
            const vm02_12 = new Vue({
                el:'#app02_12',
                data:{
                    show: true
                },
                methods:{
                    toggle(){
                        this.show = !this.show
                    }
                }
            })
        </script>
        <script type="syntaxhighlighter" class="brush: js;">
            <![CDATA[
                v-if : html tag를 생성, 제거
                v-show : css style로 제어 (display:none)       

                const vm02_12 = new Vue({
                    el:'#app02_12',
                    data:{
                        show: true
                    },
                    methods:{
                        toggle(){
                            this.show = !this.show
                        }
                    }
                })
            ]]>
        </script>
    </div>
    
    <h2>13.리스트 렌더링 - 배열</h2>
    <div>
        <div id="app02_13">
            <button type="button" @click="pushTodo">Push</button>
            <ul class="todos">
                <!-- v-for에는 기본적으로 key를 사용해야한다. -->
                <li v-for="(todo, index) in todos"
                    :key="index">
                    {{ todo.title }}
                </li>
            </ul>
        </div>
        <style></style>
        <script>
            const vm02_13 = new Vue({
                el:'#app02_13',
                data:{
                    todos:[
                        {title:'아침 먹기'},
                        {title:'점심 먹기'},
                        {title:'저녁 먹기'}
                    ]
                },
                methods:{
                    pushTodo(){
                        /* this.todos[3] = {title:'야식 먹기'}
                            값을 할당하는 방식은 반응성이 없다
                        */
                        this.todos.push({title:'야식 먹기'})
                    }
                }
            })
        </script>
        <script type="syntaxhighlighter" class="brush: js;">
            <![CDATA[
                <button type="button" @click="pushTodo">Push</button>
                <ul class="todos">
                    <!-- v-for에는 기본적으로 key를 사용해야한다. -->
                    <li v-for="(todo, index) in todos"
                        :key="index">
                        {{ todo.title }}
                    </li>
                </ul> 
                
                const vm02_13 = new Vue({
                    el:'#app02_13',
                    data:{
                        todos:[
                            {title:'아침 먹기'},
                            {title:'점심 먹기'},
                            {title:'저녁 먹기'}
                        ]
                    },
                    methods:{
                        pushTodo(){
                            /* this.todos[3] = {title:'야식 먹기'}
                                값을 할당하는 방식은 반응성이 없다
                            */
                            this.todos.push({title:'야식 먹기'})
                        }
                    }
                })
            ]]>
        </script>
    </div>
    
    <h2>14.리스트 렌더링 - 객체</h2>
    <div>
        <div id="app02_14">
            <ul class="heropy">
                <!-- 겍체에서 index는 3번째 인수로 넣어야 한다. -->
                <li v-for="(value, key, index) in heropy"
                    :key="index">
                    {{ value }}
                    <!-- 
                        {{ key }} name, age
                        {{ index }} 0,1
                    -->
                </li>
            </ul>
        </div>
        <style></style>
        <script>
            const vm02_14 = new Vue({
                el:'#app02_14',
                data:{
                    heropy:{
                        name:'HEROPY',
                        age:35,
                        homepage:'', // 값이 없어도 선언 되어 있어야 반응성을 가지게된다.
                        email:''
                    }
                }
                /* 
                    vue 인스턴스가 생성될 때 반응성을 정의한다.
                    vm02_14.heropy.homepage = 'heropy.blog'
                    렌더링 이후 추가했다면 반응성이 없다 
                    
                    이미 선언되어 있는ㄷ vm02_14.heropy에 객체를 재병합하면 반응성이 있다
                    Object.assign : 객체과 객체를 병합
                                    이미 할당된 객체는 변경해도 반응성을 가지지 않지만
                                    빈 객체 데이터를 첫번째 인수로 넣어서 병합을 하면서
                                    새로운 메모리를 참조하기 하면서 반응성을 가지게 된다.
                    vm02_14.heropy = Object.assign({}, vm02_14.heropy, {
                        homepage:'heropy.blog',
                        email:'qwe',
                        a:'A',
                        b:'B'
                    })
                */
            })
        </script>
        <script type="syntaxhighlighter" class="brush: js;">
            <![CDATA[
                <ul class="heropy">
                    <!-- 겍체에서 index는 3번째 인수로 넣어야 한다. -->
                    <li v-for="(value, key, index) in heropy"
                        :key="index">
                        {{ value }}
                        <!-- 
                            {{ key }} name, age
                            {{ index }} 0,1
                        -->
                    </li>
                </ul>
                
                const vm02_14 = new Vue({
                    el:'#app02_14',
                    data:{
                        heropy:{
                            name:'HEROPY',
                            age:35,
                            homepage:'', // 값이 없어도 선언 되어 있어야 반응성을 가지게된다.
                            email:''
                        }
                    }
                    /* 
                        vue 인스턴스가 생성될 때 반응성을 정의한다.
                        vm02_14.heropy.homepage = 'heropy.blog'
                        렌더링 이후 추가했다면 반응성이 없다 
                        
                        이미 선언되어 있는ㄷ vm02_14.heropy에 객체를 재병합하면 반응성이 있다
                        Object.assign : 객체과 객체를 병합
                                        이미 할당된 객체는 변경해도 반응성을 가지지 않지만
                                        빈 객체 데이터를 첫번째 인수로 넣어서 병합을 하면서
                                        새로운 메모리를 참조하기 하면서 반응성을 가지게 된다.
                        vm02_14.heropy = Object.assign({}, vm02_14.heropy, {
                            homepage:'heropy.blog',
                            email:'qwe',
                            a:'A',
                            b:'B'
                        })
                    */
                })
            ]]>
        </script>
    </div>
    
    <h2>15.리스트 렌더링 - Vue.set, this.$set</h2>
    <div>
        <div id="app02_15">
            <button type="button" @click="pushTodo">Push</button>
            <ul class="todos">
                <li v-for="(todo, index) in todos"
                    :key="index">
                    {{ todo.title }}
                </li>
            </ul>
            
            <button type="button" @click="addHomepage">Add Homepage property</button>
            <ul class="heropy">
                <li v-for="(value, key, index) in heropy"
                    :key="index">
                    {{ value }}
                </li>
            </ul>
        </div>
        <style></style>
        <script>
            const vm02_15 = new Vue({
                el:'#app02_15',
                data:{
                    todos:[
                        {title:'아침 먹기'},
                        {title:'점심 먹기'},
                        {title:'저녁 먹기'}
                    ],
                    heropy:{
                        name:'HEROPY',
                        age:35,
                    }
                },
                methods:{
                    pushTodo(){
                        // this.todos[3] = {title:'야식 먹기'}
                        // this.todos.push({title:'야식 먹기'})
                        // Vue.set(this.todos, 3, {title:'야식 먹기'})
                        // set의 인수 순서 : 값을 할당하려는 배열, 배열 몇번째에 넣을 것인가, 추가할 data
                        // 반응성을 부여
                        this.$set(this.todos, 3, {title:'야식 먹기'})
                    },
                    addHomepage(){
                        this.$set(this.heropy, 'homepage', 'heropy.blog')
                    }
                }
            })
        </script>
        <script type="syntaxhighlighter" class="brush: js;">
            <![CDATA[
                <button type="button" @click="pushTodo">Push</button>
                <ul class="todos">
                    <li v-for="(todo, index) in todos"
                        :key="index">
                        {{ todo.title }}
                    </li>
                </ul>
                
                <button type="button" @click="addHomepage">Add Homepage property</button>
                <ul class="heropy">
                    <li v-for="(value, key, index) in heropy"
                        :key="index">
                        {{ value }}
                    </li>
                </ul>

                const vm02_15 = new Vue({
                    el:'#app02_15',
                    data:{
                        todos:[
                            {title:'아침 먹기'},
                            {title:'점심 먹기'},
                            {title:'저녁 먹기'}
                        ],
                        heropy:{
                            name:'HEROPY',
                            age:35,
                        }
                    },
                    methods:{
                        pushTodo(){
                            // this.todos[3] = {title:'야식 먹기'}
                            // this.todos.push({title:'야식 먹기'})
                            // Vue.set(this.todos, 3, {title:'야식 먹기'})
                            // set의 인수 순서 : 값을 할당하려는 배열, 배열 몇번째에 넣을 것인가, 추가할 data
                            // 반응성을 부여
                            this.$set(this.todos, 3, {title:'야식 먹기'})
                        },
                        addHomepage(){
                            this.$set(this.heropy, 'homepage', 'heropy.blog')
                        }
                    }
                })
            ]]>
        </script>
    </div>
    
    <h2>16.메소드 이벤트 핸들러</h2>
    <div>
        <div id="app02_16">
			<ul>
				<!-- 함수를 여러개 사용 시 ;(세미콜론)으로 소스 닫기와 ()를 추가해야 한다. -->
				<li v-for="(todo, index) in todos"
                    :key="index"
					@click="clickMethod1(todo.title, $event); clickMethod2()"
					:class="'item-' + (index+1)">
                    {{ todo.title }}
                </li>
			</ul>
		</div>
        <style></style>
        <script>
            const vm02_16 = new Vue({
                el:'#app02_16',
                data:{
                    todos:[
                        {title:'아침 먹기'},
                        {title:'점심 먹기'},
                        {title:'저녁 먹기'}
                    ]
                },
				methods:{
					// 함수 clickMethod에 매개변수를 받는 형식으로 만들었지만 @click="clickMethod"처럼 매개변수없이 사용하면 이벤트 객체를 출력한다.
					clickMethod1(title, event){
						console.log('click 1', title, event.currentTarget.className, event)
					},
					clickMethod2(){
						console.log('click 2')
					}
				}
            })
        </script>
        <script type="syntaxhighlighter" class="brush: js;">
            <![CDATA[
                <ul>
                    <!-- 함수를 여러개 사용 시 ;(세미콜론)으로 소스 닫기와 ()를 추가해야 한다. -->
                    <li v-for="(todo, index) in todos"
                        :key="index"
                        @click="clickMethod1(todo.title, $event); clickMethod2()"
                        :class="'item-' + (index+1)">
                        {{ todo.title }}
                    </li>
                </ul>

                const vm02_16 = new Vue({
                    el:'#app02_16',
                    data:{
                        todos:[
                            {title:'아침 먹기'},
                            {title:'점심 먹기'},
                            {title:'저녁 먹기'}
                        ]
                    },
                    methods:{
                        // 함수 clickMethod에 매개변수를 받는 형식으로 만들었지만 @click="clickMethod"처럼 매개변수없이 사용하면 이벤트 객체를 출력한다.
                        clickMethod1(title, event){
                            console.log('click 1', title, event.currentTarget.className, event)
                        },
                        clickMethod2(){
                            console.log('click 2')
                        }
                    }
                })
            ]]>
        </script>
    </div>
    
    <h2>17.이벤트 수식어</h2>
    <div>
        <div id="app02_17">
			<div class="parent" @click.self="clickHandler">
				<div class="child"></div>
				<!-- <div class="child" @click="clickHandler"></div> -->
				<!--
					* .stop 이벤트 버블링 막기
					child를 click 하면 child, parent 순으로 출력하지만
					.stop을 추가하면 child만 출력
						<div class="child" @click.stop="clickHandler"></div>
					
					* .capture 이벤트 캡처링 발생
					parent에 .capture를 추가하면 parent, child 순으로 출력
						<div class="parent" @click.capture="clickHandler">
					
					* .self
					child에 클릭이벤트가 없을 경우 <div class="child"></div>
					child를 클릭해도 parent가 출력되지만 .self를 추가하면 child에서 클릭해도 출력하지 않는다 
						<div class="parent" @click.self="clickHandler">
							<div class="child"></div>
					
					* Capturing		부모노드에서 자식노드로 이벤트 전파
					* Bubbling		자식노드에서 부모노트로 이벤트 전파
					
					자바스크립트에서는 .stopPropagation(); 으로 버블링, 캡쳐링을 막을 수 있다.
					document.querySelector('.a').addEventListener('click', function(e){
						e.stopPropagation();
						console.log('a');
					}, true);	옵션으로 캡쳐링 발생 제어 가능
				-->
			</div>
		</div>
        <div class="a">
            <div class="b">
                <div class="c"></div>
            </div>
        </div> 
			<style>
				.a {width:300px;height:300px;background:red;margin-top:20px;}
				.b {width:200px;height:200px;background:green;}
				.c {width:100px;height:100px;background:blue;}
			</style>
			<script>
				document.querySelector('.a').addEventListener('click', function(){
					console.log('a');
				}, true);

				document.querySelector('.b').addEventListener('click', function(evt){

					console.log('b');
				}, true);

				document.querySelector('.c').addEventListener('click', function(){
					console.log('c');
				}, true);
			</script>
		
        <style>
			#app02_17 .parent {
				width:200px;
				height:200px;
				background:blue;
			}
			#app02_17 .child {
				width:100px;
				height:100px;
				background:red;
			}
		</style>
        <script>
            const vm02_17 = new Vue({
                el:'#app02_17',
				methods:{
					clickHandler(event){
						console.log(event.currentTarget.className)
					}
				}
            })
        </script>
        <script type="syntaxhighlighter" class="brush: js;">
            <![CDATA[
                <div id="app02_17">
                    <div class="parent" @click.self="clickHandler">
                        <div class="child"></div>
                        <!-- <div class="child" @click="clickHandler"></div> -->
                        <!--
                            * .stop 이벤트 버블링 막기
                            child를 click 하면 child, parent 순으로 출력하지만
                            .stop을 추가하면 child만 출력
                                <div class="child" @click.stop="clickHandler"></div>
                            
                            * .capture 이벤트 캡처링 발생
                            parent에 .capture를 추가하면 parent, child 순으로 출력
                                <div class="parent" @click.capture="clickHandler">
                            
                            * .self
                            child에 클릭이벤트가 없을 경우 <div class="child"></div>
                            child를 클릭해도 parent가 출력되지만 .self를 추가하면 child에서 클릭해도 출력하지 않는다 
                                <div class="parent" @click.self="clickHandler">
                                    <div class="child"></div>
                            
                            * Capturing		부모노드에서 자식노드로 이벤트 전파
                            * Bubbling		자식노드에서 부모노트로 이벤트 전파
                            
                            자바스크립트에서는 .stopPropagation(); 으로 버블링, 캡쳐링을 막을 수 있다.
                            document.querySelector('.a').addEventListener('click', function(e){
                                e.stopPropagation();
                                console.log('a');
                            }, true);	옵션으로 캡쳐링 발생 제어 가능
                        -->
                    </div>
                </div>
            
                <div class="a">
                    <div class="b">
                        <div class="c"></div>
                    </div>
                </div>

                const vm02_17 = new Vue({
                    el:'#app02_17',
                    methods:{
                        clickHandler(event){
                            console.log(event.currentTarget.className)
                        }
                    }
                })
            ]]>
        </script>
    </div>
	
    <h2>18.키 수식어</h2>
    <div>
        <div id="app02_18">
			<input type="text" @keydown="eventHandler" />
			<input type="text" @keydown.enter="eventHandler" />
			<input type="text" @keydown.ctrl.enter="eventHandler" /> <!-- 키 수식어 체이닝 -->
			
			<!-- 키 수식어
				.enter	.tab	.delete	.esc	.space
				.up		.down	.left	.right
				.page-down 브라우저 별 차이 있을 수 있음
			-->
		</div>
        <style></style>
        <script>
            const vm02_18 = new Vue({
                el:'#app02_18',
                methods:{
					eventHandler(e){
						/* 키 수식어를 사용하면 자바스크립트 문법 대신 keyCode 값을 받을 수 있다. 
						if(e.keyCode === 13){
							console.log('done!')
						}
						*/
						console.log('done!!')
					}
				}
            })
        </script>
        <script type="syntaxhighlighter" class="brush: js;">
            <![CDATA[
                <input type="text" @keydown="eventHandler" />
                <input type="text" @keydown.enter="eventHandler" />
                <input type="text" @keydown.ctrl.enter="eventHandler" /> <!-- 키 수식어 체이닝 -->
                
                키 수식어
                .enter	.tab	.delete	.esc	.space
                .up		.down	.left	.right
                .page-down 브라우저 별 차이 있을 수 있음   

                const vm02_18 = new Vue({
                    el:'#app02_18',
                    methods:{
                        eventHandler(e){
                            /* 키 수식어를 사용하면 자바스크립트 문법 대신 keyCode 값을 받을 수 있다. 
                            if(e.keyCode === 13){
                                console.log('done!')
                            }
                            */
                            console.log('done!!')
                        }
                    }
                })
            ]]>
        </script>
    </div>
    
    <h2>19.v-model과 한글 사용</h2>
    <div>
        <div id="app02_19">
			<input type="text" v-model="message" /><!-- v-bind : 단방향, v-model : 양방향, v-model에서 한글의 경우 글자가 완성이 되어야 반영이 되는 문제가 있다 -->
			<input type="text" @input="message2 = $event.target.value" :value="message2" /><!-- @input을 사용하면 한글 입력이 바로 반영 된다. $event : 해당 요소에서 발생한 이벤트의 객체를 담고 있는 변수 개념으로 이해  -->
			<input type="text" @input="bindMessage" :value="message3" /><!-- :value="message"로 바인딩해서 단방향 연결해야 렌더링 후에 'Hello ~'가 화면에 표시된다.  -->
			
			<div>{{ message }}</div>
			<div>{{ message2 }}</div>
			<div>{{ message3 }}</div>
		</div>
        <style></style>
        <script>
            const vm02_19 = new Vue({
                el:'#app02_19',
                data:{
                    message:'v-model',
					message2 : '@input',
					message3 : '함수형'
                },
				methods:{
					bindMessage(event){ // event는 $event가 하는 역할과 같다.
						this.message3 = event.target.value
					}
				}
            })
        </script>
        <script type="syntaxhighlighter" class="brush: js;">
            <![CDATA[
                <input type="text" v-model="message" /><!-- v-bind : 단방향, v-model : 양방향, v-model에서 한글의 경우 글자가 완성이 되어야 반영이 되는 문제가 있다 -->
                <input type="text" @input="message2 = $event.target.value" :value="message2" /><!-- @input을 사용하면 한글 입력이 바로 반영 된다. $event : 해당 요소에서 발생한 이벤트의 객체를 담고 있는 변수 개념으로 이해  -->
                <input type="text" @input="bindMessage" :value="message3" /><!-- :value="message"로 바인딩해서 단방향 연결해야 렌더링 후에 'Hello ~'가 화면에 표시된다.  -->
                
                <div>{{ message }}</div>
                <div>{{ message2 }}</div>
                <div>{{ message3 }}</div> 
                
                const vm02_19 = new Vue({
                    el:'#app02_19',
                    data:{
                        message:'v-model',
                        message2 : '@input',
                        message3 : '함수형'
                    },
                    methods:{
                        bindMessage(event){ // event는 $event가 하는 역할과 같다.
                            this.message3 = event.target.value
                        }
                    }
                })
            ]]>
        </script>
    </div>
	
	<h2>20.v-model 수식어</h2>
    <div>
        <div id="app02_20">
			<input type="text" v-model="message" />				<!-- 입력하는 바로바로 반응성 -->
			<input type="text" 
				   @change="message2 = $event.target.value" 
				   :value="message2" />							<!-- 엔터키, 포커스 블러 시 반응성 -->
			<input type="text" v-model.lazy.trim="message3" />	<!-- .lazy : @change와 동일한 기능, .trim : 문자열 공백 제거, 콘솔에서는 이런 형식으로 사용 vm02_20.message.trim()   -->
			<input type="text" v-model.number="message4" />		<!-- .number : 묹자 데이터를 숫자로 변환, 기준은 parseFloat()을 사용 -->
			<div>{{ message }}</div>
			<div>{{ message2 }}</div>
			<div>{{ message3 }}</div>
			<div>{{ typeof message4 }}</div>
		</div>
        <style></style>
        <script>
            const vm02_20 = new Vue({
                el:'#app02_20',
                data:{
                    message:'v-model',
                    message2:'@change',
                    message3:'v-model.lazy.trim',
                    message4:'v-model.number'
                }
            })
        </script>
        <script type="syntaxhighlighter" class="brush: js;">
            <![CDATA[
                <input type="text" v-model="message" />				<!-- 입력하는 바로바로 반응성 -->
                <input type="text" 
                    @change="message2 = $event.target.value" 
                    :value="message2" />							<!-- 엔터키, 포커스 블러 시 반응성 -->
                <input type="text" v-model.lazy.trim="message3" />	<!-- .lazy : @change와 동일한 기능, .trim : 문자열 공백 제거, 콘솔에서는 이런 형식으로 사용 vm02_20.message.trim()   -->
                <input type="text" v-model.number="message4" />		<!-- .number : 묹자 데이터를 숫자로 변환, 기준은 parseFloat()을 사용 -->
                <div>{{ message }}</div>
                <div>{{ message2 }}</div>
                <div>{{ message3 }}</div>
                <div>{{ typeof message4 }}</div>

                const vm02_20 = new Vue({
                    el:'#app02_20',
                    data:{
                        message:'v-model',
                        message2:'@change',
                        message3:'v-model.lazy.trim',
                        message4:'v-model.number'
                    }
                })
            ]]>
        </script>
    </div>
	
	<h2>22.컴포넌트 - 전역 등록, 지역 등록</h2>
    <div>
        <div id="app02_22">
			<my-component />	
		</div>
		
		<div id="app02_22_02">
			<my-comp /><!-- 카멜 케이스로 속성 이름을 정의했지만 태그에는 케밥 케이스로 작성(최신 버전의 경우 가능한 부분) -->
		</div>
		
        <style></style>
        <script>
			// 기존 태그와의 중복을 피하기 위해 2개 이상의 단어를 조합해서 만들어야 한다.
			// 전역 등록
			Vue.component('my-component', {
				template: '<div class="me">{{ message }}</div>',
				//data: function() {
				data() {
					return {
						message: 'Hello Vue!'
					}
				}
				/*  vue에서 data를 정의 할 때는 함수로 생성해야한다.
					컴포넌트는 여러번 재사용되면서
					data에 객체 데이터를 참조하게 되는데
					해당 객체 데이터를 변경하면
					모든 컴포넌트의 데이터가 변경되는 문제가 있어서
					data는 함수로 생성해서 return해서 사용하면 다른 컴포넌트에 영향을 주지 않는다. 
				*/
			})
			
			// 지역 등록
			const myComp = {
				template: '<div class="me">{{ message }}</div>',
				data: function() {
					return {
						message: 'Hello Vue!'
					}
				}
			}
			
            const vm02_22 = new Vue({
                el:'#app02_22'
            })
			
			const vm02_22_02 = new Vue({
                el:'#app02_22_02',
				components: {
					// 'my-comp' : myComp	my-comp로 속성명을 변경 가능
					myComp	// 속성 이름과 변수의 이름이 같을 경우 줄임 가능
				}
            })
        </script>
        <script type="syntaxhighlighter" class="brush: js;">
            <![CDATA[
                <div id="app02_22">
                    <my-component />	
                </div>
                
                <div id="app02_22_02">
                    <my-comp /><!-- 카멜 케이스로 속성 이름을 정의했지만 태그에는 케밥 케이스로 작성(최신 버전의 경우 가능한 부분) -->
                </div>

                // 기존 태그와의 중복을 피하기 위해 2개 이상의 단어를 조합해서 만들어야 한다.
                // 전역 등록
                Vue.component('my-component', {
                    template: '<div class="me">{{ message }}</div>',
                    //data: function() {
                    data() {
                        return {
                            message: 'Hello Vue!'
                        }
                    }
                    /*  vue에서 data를 정의 할 때는 함수로 생성해야한다.
                        컴포넌트는 여러번 재사용되면서
                        data에 객체 데이터를 참조하게 되는데
                        해당 객체 데이터를 변경하면
                        모든 컴포넌트의 데이터가 변경되는 문제가 있어서
                        data는 함수로 생성해서 return해서 사용하면 다른 컴포넌트에 영향을 주지 않는다. 
                    */
                })
                
                // 지역 등록
                const myComp = {
                    template: '<div class="me">{{ message }}</div>',
                    data: function() {
                        return {
                            message: 'Hello Vue!'
                        }
                    }
                }
                
                const vm02_22 = new Vue({
                    el:'#app02_22'
                })
                
                const vm02_22_02 = new Vue({
                    el:'#app02_22_02',
                    components: {
                        // 'my-comp' : myComp	my-comp로 속성명을 변경 가능
                        myComp	// 속성 이름과 변수의 이름이 같을 경우 줄임 가능
                    }
                })
            ]]>
        </script>
    </div>
	
	<h2>24.데이터 전달(props)</h2>
    <div>
        <div id="app02_24">
			<my-comp :msg="message"></my-comp><!-- props에서 카멜 케이스 (myMsg)로 선언했어도 html에서는 케밥 케이스(my-msg)로 작성  -->
		</div>
        <style></style>
        <script>
			Vue.component('my-comp', {
				template: '<div>{{ msg }}</div>',
				// props: ['msg'] msg라는 속성의 기본적인 옵션을 설정하기 위해서는 배열이 아닌 객체 데이터로 선언 해야한다.
				props: {
					msg:{
						type: [String, Number],		// 문자, 숫자데이터만 사용함을 선언, 1개일 경우 type: String
						default: 'Default!',		// 기본값 설정 , <my-comp></my-comp> 처럼 기본 값이 없을 경우 Default 출력
						required: true,				// 필수 속성이 필요한 경우
						validator: function(value){	// value = message
							return value === 'Hello'
						}
					}
				}
			})
			
            const vm02_24 = new Vue({
                el:'#app02_24',
                data(){
                    return {
						message: 'Hello'
					}
                }
            })
        </script>
        <script type="syntaxhighlighter" class="brush: js;">
            <![CDATA[
                <my-comp :msg="message"></my-comp><!-- props에서 카멜 케이스 (myMsg)로 선언했어도 html에서는 케밥 케이스(my-msg)로 작성  -->       

                Vue.component('my-comp', {
                    template: '<div>{{ msg }}</div>',
                    // props: ['msg'] msg라는 속성의 기본적인 옵션을 설정하기 위해서는 배열이 아닌 객체 데이터로 선언 해야한다.
                    props: {
                        msg:{
                            type: [String, Number],		// 문자, 숫자데이터만 사용함을 선언, 1개일 경우 type: String
                            default: 'Default!',		// 기본값 설정 , <my-comp></my-comp> 처럼 기본 값이 없을 경우 Default 출력
                            required: true,				// 필수 속성이 필요한 경우
                            validator: function(value){	// value = message
                                return value === 'Hello'
                            }
                        }
                    }
                })
                
                const vm02_24 = new Vue({
                    el:'#app02_24',
                    data(){
                        return {
                            message: 'Hello'
                        }
                    }
                })
            ]]>
        </script>
    </div>
	
	<h2>25.사용자 지정 이벤트($emit)</h2>
    <div>
        <div id="app02_25">
			<my-comp :my-msg="message" @my-event="updateMessage"></my-comp>
		</div>
        <style></style>
        <script>
			// 자식
			Vue.component('my-comp', {
				template: '<div @click="updateMsg">{{ myMsg }}</div>',
				props: {
					myMsg: String
				},
				methods:{
					updateMsg(){
						//this.myMsg = 'Good'
						this.$emit('my-event','Good')	// $emit : 부모 요소로 특정한 이벤트 (my-event)를 전달하면서 같이 전달하는 데이터 'Good'
					}
				}
			})
			
			// 부모
            const vm02_25 = new Vue({
                el:'#app02_25',
                data(){
                    return {
						message: 'Hello'
					}
                },
				methods:{
					updateMessage(value){
						this.message = value
					}
				}
            })
			// 자식 컴포넌트에서 부모 컴포넌트의 값을 변경할 수 있지만 콘솔에러가 발생한다. 이를 막기 위해 이벤트를 부모에게 전달해서 부모의 methods에서 값을 변경하게 하면 된다.
        </script>
        <script type="syntaxhighlighter" class="brush: js;">
            <![CDATA[
                <my-comp :my-msg="message" @my-event="updateMessage"></my-comp>

                // 자식
                Vue.component('my-comp', {
                    template: '<div @click="updateMsg">{{ myMsg }}</div>',
                    props: {
                        myMsg: String
                    },
                    methods:{
                        updateMsg(){
                            //this.myMsg = 'Good'
                            this.$emit('my-event','Good')	// $emit : 부모 요소로 특정한 이벤트 (my-event)를 전달하면서 같이 전달하는 데이터 'Good'
                        }
                    }
                })
                
                // 부모
                const vm02_25 = new Vue({
                    el:'#app02_25',
                    data(){
                        return {
                            message: 'Hello'
                        }
                    },
                    methods:{
                        updateMessage(value){
                            this.message = value
                        }
                    }
                })
                // 자식 컴포넌트에서 부모 컴포넌트의 값을 변경할 수 있지만 콘솔에러가 발생한다. 이를 막기 위해 이벤트를 부모에게 전달해서 부모의 methods에서 값을 변경하게 하면 된다.
            ]]>
        </script>
    </div>
	
	<h2>26.컴포넌트 slot</h2>
    <div>
        <div id="app02_26">
			<!-- 컴포넌트가 렌더링 될때 컴포넌트 안의 내용은 출력되지 않으나 slot을 사용하면 가능하다.  -->
			<!--
			<my-comp>Hello Slot!</my-comp>
			<my-comp></my-comp>
			<my-comp>
				<div slot="slot1">Hello Slot!</div>
				<input type="text" />
			</my-comp>
			-->
			<my-comp>
				<!-- myProps 원하는 이름으로 지정, mySlotData = my-slot-data -->
				<!--
				<template slot-scope="myProps">
					{{ myProps.mySlotData }}
				</template>
				-->
				<!-- 속성의 이름으로 연결해서 사용 가능 -->
				<template slot-scope="{mySlotData}">
					{{ mySlotData }}
				</template>
			</my-comp>
		</div>
        <style></style>
        <script>
			Vue.component('my-comp', {
				// template: '<div><slot></slot></div>'				 					컴포넌트의 내용을 출력
				// template: '<div><slot>대체 콘텐츠</slot></div>'				   	   컴포넌트에 컨텐츠가 없을 시 대체 콘텐츠 출력
				// template: '<div> <slot></slot> <slot name="slot1"></slot> </div>'	컴포넌트의 순서와 상관없이 선언한 slot의 순서대로 출력
				template: '<div><slot :my-slot-data="message"></slot></div>',			// 범위를 가지는 slot
                data(){
                    return {
						message: 'Hello Slot~~'
					}
                }
			})
			
            const vm02_26 = new Vue({
                el:'#app02_26'
            })
        </script>
        <script type="syntaxhighlighter" class="brush: js;">
            <![CDATA[
                <!-- 컴포넌트가 렌더링 될때 컴포넌트 안의 내용은 출력되지 않으나 slot을 사용하면 가능하다.  -->
                <!--
                <my-comp>Hello Slot!</my-comp>
                <my-comp></my-comp>
                <my-comp>
                    <div slot="slot1">Hello Slot!</div>
                    <input type="text" />
                </my-comp>
                -->
                <my-comp>
                    <!-- myProps 원하는 이름으로 지정, mySlotData = my-slot-data -->
                    <!--
                    <template slot-scope="myProps">
                        {{ myProps.mySlotData }}
                    </template>
                    -->
                    <!-- 속성의 이름으로 연결해서 사용 가능 -->
                    <template slot-scope="{mySlotData}">
                        {{ mySlotData }}
                    </template>
                </my-comp> 
                
                Vue.component('my-comp', {
                    // template: '<div><slot></slot></div>'				 					컴포넌트의 내용을 출력
                    // template: '<div><slot>대체 콘텐츠</slot></div>'				   	   컴포넌트에 컨텐츠가 없을 시 대체 콘텐츠 출력
                    // template: '<div> <slot></slot> <slot name="slot1"></slot> </div>'	컴포넌트의 순서와 상관없이 선언한 slot의 순서대로 출력
                    template: '<div><slot :my-slot-data="message"></slot></div>',			// 범위를 가지는 slot
                    data(){
                        return {
                            message: 'Hello Slot~~'
                        }
                    }
                })
                
                const vm02_26 = new Vue({
                    el:'#app02_26'
                })
            ]]>
        </script>
    </div>
</body>
</html>