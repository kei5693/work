<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
    <title>자바스크립트 200제 - 입문</title>

    <script type="text/javascript" src="../common/js/jquery-1.9.1.min.js"></script>

    <script type="text/javascript" src="../common/js/XRegExp.js"></script>
    <script type="text/javascript" src="../common/js/shCore.js"></script>
    <script type="text/javascript" src="../common/js/shBrushJScript.js"></script>
    <link type="text/css" rel="stylesheet" href="../common/css/shCore.css"/>
    <link type="text/css" rel="Stylesheet" href="../common/css/shThemeDefault.css" />
    <script type="text/javascript">SyntaxHighlighter.all();</script>
    
    <style>
		body,button,dd,dl,dt,fieldset,form,h1,h2,h3,h4,h5,h6,
		input,legend,li,ol,p,select,table,td,textarea,th, ul {margin:0;padding:0;}
		body,button,input,select,table,textarea {font-size:12px;font-family:Malgun Gothic, Dotum, '돋움', Helvetica, "Apple SD Gothic Neo", sans-serif;}
		button,input {border-radius:0;}
		fieldset,img {border:0;}
		ol,ul {list-style:none;}
		address,em {font-style:normal;}
		a {text-decoration:none;}
		a:hover {text-decoration:underline;}
		iframe {overflow:hidden;margin:0;padding:0;border:0;}
		.blind {position:absolute;overflow:hidden;clip:rect(0 0 0 0);margin:-1px;width:1px;height:1px;}

		#js_ex200 ul,
		#js_ex200 ol,
		#js_ex200 button,
		#js_ex200 dd,
		#js_ex200 dl,
		#js_ex200 dt,
		#js_ex200 fieldset,
		#js_ex200 form,
		#js_ex200 h1,
		#js_ex200 h2,
		#js_ex200 h3,
		#js_ex200 h4,
		#js_ex200 h5,
		#js_ex200 h6,
		#js_ex200 input,
		#js_ex200 legend,
		#js_ex200 li,
		#js_ex200 ol,
		#js_ex200 p,
		#js_ex200 select,
		#js_ex200 table,
		#js_ex200 td,
		#js_ex200 textarea,
		#js_ex200 th {margin:0;padding:0;}
		#js_ex200 button,
		#js_ex200 input {border-radius:0;}
		#js_ex200 fieldset,
		#js_ex200 img {border:0;}
		#js_ex200 ol,
		#js_ex200 ul {list-style:none;}
		#js_ex200 address,
		#js_ex200 em {font-style:normal;}
		#js_ex200 a {text-decoration:none;}
		#js_ex200 a:hover {text-decoration:underline;}
		#js_ex200 iframe {overflow:hidden;margin:0;padding:0;border:0;}
		#js_ex200 .blind {position:absolute;overflow:hidden;clip:rect(0 0 0 0);margin:-1px;width:1px;height:1px;}

		#js_ex200 .point_txt {color:red;}
		#js_ex200 .interval01 {margin-top:0 !important;}
		#js_ex200 .syntaxhighlighter {margin:10px 0 0 0 !important;}
		#js_ex200 .syntaxhighlighter .line {line-height: 24px !important;font-size: 14px !important;}
		#js_ex200 .syntaxhighlighter table td.gutter .line {padding: 0 0.5em 0 0.5em !important;}

		#js_ex200 {margin:4vw 2vw;}
		#js_ex200 {font-size:12px;line-height:1.4;font-family: Malgun Gothic, Dotum, '돋움', Helvetica, "Apple SD Gothic Neo", sans-serif;}
		#js_ex200 h1 {text-align:center;}
		#js_ex200 h2 {margin-bottom:10px;display: flex;word-break: keep-all;font-size: 18px;}
		#js_ex200 h2 span:first-child {/*min-width: 86px;*/position:relative;padding-right: 12px;white-space: pre;}
		#js_ex200 h2 span:first-child:after {content:':';position:absolute;top:0;right: 3px;}
		#js_ex200 > div {margin-top:20px;}
		#js_ex200 > div + div {margin-top:100px;}

		#js_ex200 dd + dt {margin-top:10px;}

		#js_ex200 .bull_list li {position:relative;padding-left:11px;}
		#js_ex200 .bull_list > li + li {margin-top:5px;}
		#js_ex200 .bull_list li > p {font-weight:bold;}
		#js_ex200 .bull_list li:after {content:'';position:absolute;top:7px;left:3px;width:3px;height:3px;background:#000;}
		#js_ex200 .bull_list > li > ul > li {margin-top:5px;}
		#js_ex200 .bull_list > li > ul > li:after {top:8px;height:1px;}

		#js_ex200 .content {margin-top:20px;}
		#js_ex200 .content > * {margin-top:10px;}
		#js_ex200 .content .syntaxhighlighter {margin:0 0 0 0 !important;}
		#js_ex200 .desc {margin-top:10px;}
		#js_ex200 .desc > ol > li {display:flex;word-break: keep-all;}
		#js_ex200 .desc > ol > li + li {margin-top:5px;}
		#js_ex200 .desc > ol > li > span:first-child {text-align: right;min-width:35px;margin-right:10px;}

		.ex43 {overflow-x:scroll;}
		.ex43 > ul {display: flex;text-align: center;margin-left: -5px !important;}
		.ex43 > ul > li {min-width: 150px;border: 1px solid #000;padding: 10px !important;margin: 0 5px !important;box-sizing: border-box;display: flex;align-items: flex-end;}
		.ex43 > ul > li > div {width:100%;}
		.ex43 > ul > li > div li {border:1px solid #000;padding: 5px !important;}
		.ex43 > ul > li > div li:first-child {background:#ccc;}
		.ex43 > ul > li > div li + li {margin-top: 10px !important;}
		.ex43 > ul > li > div p {margin-top:10px !important;min-height: 50px;}

		.ex43_02 {overflow-x:scroll;}
		.ex43_02 ul {display:flex;}
		.ex43_02 li {position:relative;width:220px;padding:10px !important;border:1px solid #000;}
		.ex43_02 li + li {margin-left:44px !important;}
		.ex43_02 li + li:after {content:'←';position:absolute;top:50%;left:-28px;width:20px;height:20px;margin-top:-10px;}
		.ex43_02 li + li pre span {display:inline-block;min-width:24px;height:12px;background:red;}
		.ex43_02 li > strong {display:block;}

		@media (min-width:1024px) {
			#js_ex200 .syntaxhighlighter {max-height:25vw; overflow-y:scroll;}
			#js_ex200 .syntaxhighlighter .line {line-height: 18px !important;}
		}
		@media (max-width:768px) {
			#js_ex200 {margin:10vw 4vw;}
			#js_ex200 .syntaxhighlighter {max-height:92vw; overflow-y:scroll;}
			#js_ex200 .syntaxhighlighter table td.gutter .line {padding: 0 5px !important;}
			#js_ex200 .syntaxhighlighter .line {line-height: 24px !important;padding: 0 10px !important;}
		}
	</style>
</head>
<body>
    
<!-- js_ex200 -->
<div id="js_ex200">
    <h1>javascript 200제</h1>
    <div>
        <h2><span>입문 005</span>값(value)과 변수(variable) 이해하기</h2>
        <div class="content">
            <p>컴퓨터는 데이터를 비트로 처리하지만, 프로그래밍에서는 값(value)으로 나타내는데 컴퓨터가 동시에 많은 값을 유지하고 처리하려면, 어딘가에 값을 저장해야 하는데 그 공간을 변수(valriable)라고 한다.</p>
            <script type="syntaxhighlighter" class="brush: js;">
            <![CDATA[
                foo = "bar"
            ]]>
            </script>
            <p>키워드 없이 변수를 할당하면 변수의 암시적 선언, 변수가 선언되는 범위(scope)때문에 var 키워드를 사용한 명시적 변수 선언을 권장</p>
        </div>
        <script type="syntaxhighlighter" class="brush: js;">
        <![CDATA[
            var name = "Peter"
            var number = 200
            var isTrue = true
            var nothing = null
            var empty = undefined
            var list = []
            var ref = {}
            var func = function(){}
        ]]>
        </script>
        <div class="desc">
            <ul class="bull_list">
                <li><p>선언 키워드</p>var 키워드를 사용해서 변수를 선언한다. 다른 컴파일 언어와 달리 값을 변수에 저장할 때 유형을 명시하지 않아도 되며 변수의 값에 의해 동적으로 유형이 결정된다. 이를 동적 바인딩(Dynamic Binding)이라 한다.</li>
                <li><p>변수명</p>var 키워드 다음에 변수명을 작성하며 변수명은 자바스크립트에서 사용, 예정중인 키워드를 선언하면 에러 발생</li>
                <li><p>등호</p>등호 기준 왼쪽에 변수명, 오른쪽에 값을 작성해서 변수 메모리에 값을 대입한다.</li>
                <li><p>값</p>변수에는 다양한 값을 넣을수 있다.(단일 자료형의 값, 표현식, 함수)</li>
                <li><p>자바스크립트 키워드</p>break, case, catch, class, const, continue, debugger, default, delete, do, else, export, extends, finally, for, function, if, import, in, instanceof, let, new, return, superr, switch, this, throw, try, typeof, var, void, with, yield</li>
            </ul>
        </div>
    </div>
    
    <div>
        <h2><span>입문 006</span>자바스크립트 문장 배우기</h2>
        <div class="content">
            <p>자바스크립트의 구문 패턴은 표현식과 명령문으로 나뉜다.</p>
            <ul class="bull_list">
                <li><p>표현식(Expressions)</p>연산자를 통해 값을 생성하거나, 변수 또는 함수 인자로 값을 넣을 때 표현식을 사용.</li>
            </ul>
        </div>
        <script type="syntaxhighlighter" class="brush: js;">
        <![CDATA[
            (3 + 12) / 5
            declaredVariable
            greeting("Hello")
        ]]>
        </script>
        
        <div class="content">
            <ul class="bull_list">
                <li><p>명령문(Statements)</p>일종의 행동 또는 행위를 수행하게 하는 코드. (ex : if, if-else, for, switch)</li>
            </ul>
        </div>
        <script type="syntaxhighlighter" class="brush: js;">
        <![CDATA[
            if (true) {

            }
        ]]>
        </script>
        
        <div class="content">
            <p>명령문 작성 시 표현식이 대신 쓰여질 경우 표현식 명령문(Expression Statement)이라 한다.</p>
        </div>
        <script type="syntaxhighlighter" class="brush: js;">
        <![CDATA[
            function greeting() {
              "hello"
              "Chloe" + 3
              greeting()
            }

            greeting(if(true) { console.log("It is not acceptable") })
        ]]>
        </script>
        <div class="desc">
            <ol>
                <li><span>1~5</span>함수를 정의하고 작성할 때 2~3처럼 명령문 대신 표현식을 사용할 수 있다.</li>
                <li><span>7</span>함수의 인자로 값이 아닌 명령문을 넣으면 잘못된 문장으로 구문 오류 발생</li>
            </ol>
        </div>
    </div>

    <div>
        <h2><span>입문 007</span>주석 처리하기</h2>
        <div class="content">
            
        </div>
        <script type="syntaxhighlighter" class="brush: js;">
        <![CDATA[
            // x 변수에 "a" 값을 할당하여 선언합니다.
            var x = "a";
            console.log(x); // 변수 x 를 console.log 로 출력합니다.

            /*
            x = "b";
            console.log(x);
            */
        ]]>
        </script>
        <div class="desc">
            <ol>
                <li><span>1,3</span>한문장 주석</li>
                <li><span>5~8</span>블록 단위 주석</li>
            </ol>
        </div>	
    </div>
    
    <div>
        <h2><span>입문 008</span>자료형 이해하기</h2>
        <div class="content">
            <p>프로그래밍 언어는 값을 특정 유형으로 분류하는데 이를 자료형 또는 type이라 한다. 자바스크립트는 크게 2가지 타입으로 구분한다.</p>
            <ul class="bull_list">
                <li><p>원시 타입(Primitive Data Type)</p>
                    값이 변수에 할당될 때 메모리 상에 고정된 크기로 저장되므로 변경 불가능한 값, 불변값(Immutable Value)인 특징을 가진다.
                    숫자 5(8바이트)를 x에 대입 하면 x는 8바이트 공간에 직접 숫자5를 보유하게 된다.
                    <ul>
                        <li><p>숫자형(Number)</p>정수, 실수 구분없이 하나로 포괄, 숫자형 끼리의 연산 가능</li>
                        <li><p>문자형(String)</p>작은 따옴표(''), 큰 따옴표("") 안에 한 글자 이상의 문자, 기호, 숫자가 있는 자료형.</li>
                        <li><p>불린형(Boolean)</p>참(true), 거짓(false) 두 가지 값을 가진 자료형</li>
                        <li><p>심볼형(Symbol)</p>ES6부터 추가된 원시 자료형. 유일하게 변형 불가능한 자료형으로 참조형의 키(key)로도 사용 가능.</li>
                        <li><p>null, undefined</p>null은 빈 값, undefined는 존재하지 않는 값을 의미</li>
                    </ul>
                </li>
                <li><p>참조 타입(Reference Data Type)</p>
                    고정된 크기가 아닌 값의 메모리 주소를 변수에 할당하여 값을 참조한다. 변수의 값을 불러오려면 저장되어 있는 메모리 주소를 찾아가서 값을 가져 온다.
                    <ul>
                        <li><p>객체(Object)</p>{} 안에 키:값 형태로 이루어진 속성들의 모음으로 키는 반드시 문자형이어야 하고 키를 통해 매핑된 값에 접근할 수 있다.</li>
                        <li><p>전역 객체(Global Object)</p> 모든 객체의 유일한 최상위 객체를 의미하며 전체 코드에서 1개만 존재할 수 있다. 이를 부모 삼아 함수(Function), 배열(Array), 원시 자료형을 객체로 감싼 새로운 형태의 객체(String, Number, Boolean)와 특수 연산에 특화된 내장 객체(Math, JSON, RegeEx) 그리고 Iteable과 Collection 특성의 객체(Map, Set, WeakMap, WeakSet) 등의 표준 내장 객체가 있다.</li>
                    </ul>
                </li>
            </ul>
        </div>
        <script type="syntaxhighlighter" class="brush: js;">
        <![CDATA[
            var x = 5;              // 숫자형(Number)
            var y = 'five';         // 문자형(String)
            var isTrue = true;      // 불린형(Boolean)
            var empty = null;       // null
            var nothing             // undefined
            var sym = Symbol('me'); // Symbol
            
            // 객체(Object)
            var item = {
                price: 5000,
                count: 10
            }; 
            
            // 배열(Array)
            var fruits = ['apple', 'orange', 'kiwi'];   
            
            // 함수(function)
            var addFruit = function (fruit) {
                fruits.push(fruit);
            }                                           
            addFruit('watermelon');
            console.log(fruits);
        ]]>
        </script>
    </div>
    
    <div>
        <h2><span>입문 009</span>콘솔로 자료형 출력하기</h2>
        <div class="content">
            console은 자바스크립트의 내장 객체로 log 메소드와 같이 사용하여 괄호안에 대입한 값을 로그 메시지로 출력한다.
        </div>
        <script type="syntaxhighlighter" class="brush: js;">
        <![CDATA[
            var str = 'JavaScript';
            var num = 200;
            var arr = [1, 2, 3, 4, 5];
            var obj = {a: 1, b: 2, c: 3};

            console.log(str); // JavaScript
            console.log(num); // 200
            console.log(arr); // [1, 2, 3, 4, 5]
            console.log(obj); // {a: 1, b: 2, c: 3}
        ]]>
        </script>
        <div class="desc">
            <p>그외 다른 console 메소드</p>
            <ul>
                <li>console.debug('log와 동일한 로그 메시지 출력')</li>
                <li>console.error('에러메시지 출력')</li>
                <li>console.info('정보성 메시지 출력')</li>
                <li>console.warn('경고성 메시지 출력')</li>
            </ul>
        </div>
    </div>
    
    <div>
        <h2><span>입문 010</span>조건문 배우기 - if</h2>
        <div class="content">
            <p>어떤 조건이 참, 거짓인지에 따라 실행 여부를 결정하는 구문. 특정 코드를 실행하게 실행하지 못하게 만들수있다.</p>
            <script type="syntaxhighlighter" class="brush: js;">
            <![CDATA[
                if(표현식)
                   명령문
            ]]>
            </script>
            <p>표현식을 소괄호()로 둘러싼 형태에 표현식에는 의사결정을 할 수 있는 조건문을 작성한다. 조건문의 결과값은 항상 불린형 값이어야 하며, if 조건문 결과값이 true인 경우에만 다음 명령문이 실행된다.</p>
        </div>
        <script type="syntaxhighlighter" class="brush: js;">
        <![CDATA[
            var result = true;
            if (result) console.log('result 가 참 입니다.');
            if (!result)
              console.log('실행되지 않습니다.');
            if (result) {
              console.log('result 의 결과');
              console.log('>> 참 입니다.');
            }
        ]]>
        </script>
        <div class="desc">
            <ol>
                <li><span>1</span>변수 result에 불린값 true 대입</li>
                <li><span>2~4</span>result 가 참 입니다. 출력<br>
                    resul는 참(true)이므로 다음 명령문이 실행된다. !는 변수의 값을 반대(true ↔ false)로 바꾼다. result가 참이 아니어서 출력되지 않음.</li>
                <li><span>5~8</span>result 의 결과<br>>> 참 입니다.<br>
                    다음 명령문이 1줄 이상인 경우 중괄호{}로 블록을 잡을수 있고 변수가 참일 경우 명령문 블록을 모두 실행한다.</li>
            </ol>
        </div>	
    </div>
    
    <div>
        <h2><span>입문 011</span>조건문 배우기 - if, else if, else</h2>
        <div class="content">
            <p>else if, else는 if의 결과값이 false일 때 샐행되는 조건문. (==는 동등 연산자로 == 기준 좌우의 값을 비교해서 값이 같으면 참,거짓을 반환한다.)</p>
        </div>
        <script type="syntaxhighlighter" class="brush: js;">
        <![CDATA[
            var number = 2;
            if (number == 1) {
              console.log('number 는 1 입니다');
            } else if (number == 2) {
              console.log('number 는 2 입니다');
            } else if (number == 3) {
              console.log('number 는 3 입니다');
            } else {
              console.log('number 는 1,2,3 중 해당되는 것이 없습니다.');
            }
        ]]>
        </script>
        <div class="desc">
            <ol>
                <li><span>1</span>변수 number에 숫자2 대입</li>
                <li><span>2</span>변수가 1과 같으면 실행하는 조건문</li>
                <li><span>4</span>조건문이 불충족 시 else if로 다음 조건문을 실행하게 할 수 있다. 4라인 조건문은 참이어서 5번 라인의 "number 는 2 입니다" 출력</li>
                <li><span>6</span>이미 조건문을 충족해서 6~10라인은 실행되지 않음</li>
                <li><span>8~9</span>else는 다른 조건식을 충족하지 않는 경우에 실행</li>
            </ol>
        </div>	
        <script type="syntaxhighlighter" class="brush: js;">
        <![CDATA[
            if(표현식1){           // if 조건1
                명령문1
            } else if(표현식2){    // else if 조건2
                명령문2
            } else {               // else 모든 조건식에도 만족되지 않을때
                명령문3
            }
        ]]>
        </script>
    </div>
    
    <div>
        <h2><span>입문 012</span>반복문 배우기 - switch</h2>
        <div class="content">
            <p>if 조건문에 비해 switch를 사용하면 정돈된 코드를 만들수 있다.</p>
            <script type="syntaxhighlighter" class="brush: js;">
            <![CDATA[
                switch (표현식) {
                  case 값1:
                    명령문1
                    break;
                  case 값2:
                    명령문2
                    break;
                  default:
                    명령문3
                    break;
                }
            ]]>
            </script>
            <ul>
                <li>표현식과 case문의 값을 일치연산자(===)로 순차적으로 참이 나올때까지 비교한 후 참, 거짓을 반환한다.</li>
                <li>값이 일치하면 해당 명령문을 실행하고 break으로 다음 코드를 실행하지 않고 switch 조건문을 완료한다.</li>
                <li>일치하는 case값이 없을 경우 default의 명령문을 실행한다.</li>
            </ul>
        </div>
        <script type="syntaxhighlighter" class="brush: js;">
        <![CDATA[
            var subject = '자바스크립트';
            switch (subject) {
              case 'C언어':
                console.log('초보자를 위한 C++ 200제');
                break;
              case '자바스크립트':
                console.log('초보자를 위한 자바스크립트 200제');
                break;
              case '파이썬':
                console.log('초보자를 위한 파이썬 200제');
                break;
              default:
                console.log('이젠 초보자가 아닙니다');
                break;
            }
        ]]>
        </script>
        <div class="desc">
            <ol>
                <li><span>1</span>변수 subject에 "자바스크립트" 대입</li>
                <li><span>2</span>switch에 표현식을 넣는다.</li>
                <li><span>3~5</span>case문과 일치하지 않으므로 다음 case를 비교</li>
                <li><span>6~8</span>subject와 case의 값이 일치하므로 해당 명령문이 실행되고 break으로 조건문을 빠져나간다.</li>
                <li><span>9~14</span>이미 조건문을 빠져나가서 9~14라인은 실행되지 않는다.</li>
            </ol>
        </div>	
    </div>
    
    <div>
        <h2><span>입문 013</span>반복문 배우기 - for</h2>
        <div class="content">
            <p>특정 코드를 반복하는 흐름을 제어한다.</p>
            <script type="syntaxhighlighter" class="brush: js;">
            <![CDATA[
                for (초기값; 조건식; 어떤 간격으로) {
                    실행할 문장
                }
            ]]>
            </script>
            <script type="syntaxhighlighter" class="brush: js;">
            <![CDATA[
                
                for (var i = 0; i < 10; i++) {
                    console.log(i + '번째 반복 문장 입니다.');
                }
                
                /*
                    0번째 반복 문장 입니다.
                    1번째 반복 문장 입니다.
                    2번째 반복 문장 입니다.
                    3번째 반복 문장 입니다.
                    4번째 반복 문장 입니다.
                    5번째 반복 문장 입니다.
                    6번째 반복 문장 입니다.
                    7번째 반복 문장 입니다.
                    8번째 반복 문장 입니다.
                    9번째 반복 문장 입니다.
                */
            ]]>
            </script>
        </div>
        <div class="desc">
            <ol>
                <li><span>1~3</span>초기값 : 변수 i에 0을 할당.<br>조건식 : i가 10이 될 때까지 블록 안의 문장을 반복 실행.<br>반복 실행할 횟수 : i++은 i를 1씩 증가 시켜 10회의 반복을 하게 된다.</li>
            </ol>
        </div>
        
        <div class="content">
            <p>반복문의 흐름 제어</p>
            <ul class="bull_list interval01">
                <li><p>continue</p>다음의 문장들은 무시하고 다음 반복으로 이동</li>
                <li><p>break</p>break이 있는 지점까지 실행후 반복문 종료</li>
            </ul>
        </div>
        <script type="syntaxhighlighter" class="brush: js;">
        <![CDATA[
            var hometown = [
                {name: '남준', place: '일산', city: '고양'},
                {name: '진', place: '과천'},
                {name: '호석', place: '광주', city: '전라도'},
                {name: '지민', place: '부산', city: '경상도'}
            ];

            for (var i = 0; i < hometown.length; i++) {
                var h = hometown[i];
                if (!h || !h.city) continue;

                console.log(i + ' 번째 실행입니다.');

                if (h.name === '호석') {
                    console.log(h.name + '의 고향은 ' + h.city + ' ' + h.place + ' 입니다.');
                    break;
                }
            }
            
            /*
                0 번째 실행입니다.
                2 번째 실행입니다.
                호석의 고향은 전라도 광주 입니다.
            */
        ]]>
        </script>
        <div class="desc">
            <ol>
                <li><span>1~6</span>변수 hometown에 배열 자료형 값 대입</li>
                <li><span>8</span>0부터 배열 요소의 숫자(4)만큼 1씩 증가를 반복한다.</li>
                <li><span>9</span>배열의 i번째 요소를 변수 h에 대입</li>
                <li><span>10</span>변수 h 또는 h에 할당된 객체값을 확인하는 조건문. 배열 요소의 정보가 없다면 continue 다음의 문장을 무시하고 다음 반복문을 실행</li>
                <li><span>12</span>배열의 요소가 있다면 concole.log 출력</li>
                <li><span>14~17</span>h의 name 속성이 '호석'과 일치하는지 비교하는 조건문. 조건을 충족하는 배열 요소까지 실행 후 반복문 종료 </li>
            </ol>
        </div>	
    </div>
    
    <div>
        <h2><span>입문 014</span>반복문 배우기 - for in</h2>
        <div class="content">
            <p>순회조건과 내부 요소에 접근하는 방법이 for 반복문과 다르게 in 키워드를 사용한다.</p>
            <script type="syntaxhighlighter" class="brush: js;">
            <![CDATA[
                for (속성명 in 반복할 대상) {
                  
                }
            ]]>
            </script>
        </div>
        <script type="syntaxhighlighter" class="brush: js;">
        <![CDATA[
            var store = { snack: 1000, flower: 5000, beverage: 2000 };

            for (var item in store) {
              if (!store.hasOwnProperty(item)) continue;

              console.log(item + ' 는 가격이 ' + store[item] + ' 입니다.')
            }
            /*
                snack 는 가격이 1000 입니다.
                flower 는 가격이 5000 입니다.
                beverage 는 가격이 2000 입니다.
            */
        ]]>
        </script>
        <div class="desc">
            <ol>
                <li><span>1</span>변수에 객체값 할당</li>
                <li><span>3</span>객체를 순환하는 for-in 반복문</li>
                <li><span>4</span>for-in 반복문으로 내부 요소 정보가 전달되어 코드가 실행되는 부분. 매 반복마다 hasOwnProperty로 store객체에 item 키 정보가 있는지 확인한다. 없으면 continue를 통해 다음 반복문 순서로 이동.(hasOwnProperty를 통해 객체 안에 속성이 있는지 한 번 더 확인하는 것을 권장)</li>
                <li><span>6</span>정상적으로 접근한 요소에 대해 출력. item에는 순회하며 접근한 각 요소의 속성명(키정보)이 순서대로 "snack", "flower", "beverage"가 할당되어 속성명을 통해 속성값을 가져올수 있다.</li>
                <li><span>*</span>hasOwnProperty는 자바스크립트 객체 자료형에 내장된 속성으로 삭제하지 않는 한, 별도로 정의하지 않아도 사용 가능하지만 for-in에서는 순회 가능한 객체의 요소를 열거하는데 내장 속성은 열거하지 않고 사용자가 정의한 속성값만 열거한다.</li>
            </ol>
        </div>
    </div>
    
    <div>
        <h2><span>입문 015</span>반복문 배우기 - while</h2>
        <div class="content">
            <ul class="bull_list">
                <li><p>while 반복문</p>지시어 while로 시작하고 그 다음 소괄호 ()안에 조건식이 들어가는데 결과값이 true, false만 가능하다. 조건식이 true인 경우 중괄호 {}안의 문장을 실행하고 조건식이 false가 되면 반복문 종료한다.(break, continue 사용할 수 있다.)</li>
            </ul>
            <script type="syntaxhighlighter" class="brush: js;">
            <![CDATA[
                while (조건식) {
                    반복할 문장
                }
            ]]>
            </script>
            <ul class="bull_list">
                <li><p>do-while 반복문</p>처음은 조건식 결과와 상관없이 무조건 실행하고 다음 흐름은 while과 동일</li>
            </ul>
            <script type="syntaxhighlighter" class="brush: js;">
            <![CDATA[
                do {
                    반복할 문장
                } while (조건식)
            ]]>
            </script>
        </div>
        <script type="syntaxhighlighter" class="brush: js;">
        <![CDATA[
            var hometown = [
                {name: '진', city: '과천'},
                {name: '남준', place: '일산', city: '고양'},
                {name: '호석', place: '광주', city: '전라도'},
                {name: '지민', place: '부산', city: '경상도'}
            ];

            var isHometown = function(h, name) {
                console.log(`함수가 실행되었습니다. ${h.city} 도시에서 ${name} 을 찾습니다.`);

                if (h.name === name) {
                    console.log(`${h.name} 의 고향은 ${h.city} ${h.place} 입니다.`);
                    return true;
                }	
                return false;
            }

            var h;
            while (h = hometown.shift()) {
                if (!h.name || !h.place || !h.city) continue;

                var result = isHometown(h, '호석');
                if (result) break;
            }

            var i = 0;
            var names = ['남준', '정국', '윤기', '호섭'];
            var cities = ['경기', '부산', '대구', '광주'];
            do {
                hometown[i] = {name: names[i], city: cities[i]};
                i++;
            } while (i < 4);

            console.log(hometown);
            /*
                함수가 실행되었습니다. 고양 도시에서 호석 을 찾습니다.
                함수가 실행되었습니다. 전라도 도시에서 호석 을 찾습니다.
                호석 의 고향은 전라도 광주 입니다.
                [{name: "남준", city: "경기"}
                {name: "정국", city: "부산"}
                {name: "윤기", city: "대구"}
                {name: "호섭", city: "광주"}]
            */
        ]]>
        </script>
        <div class="desc">
            <ol>
                <li><span>1~6</span>변수에 객체 자료형 요소가 있는 배열을 할당</li>
                <li><span>8~16</span>인자값 h, name을 받는 함수 isHometown를 선언한다. 인자값 h.name과 name의 값을 비교해서 같으면 console.log()를 출력하고 true를 반환, 다르면 false를 반환하고 함수 종료</li>
                <li><span>18</span>shift()는 배열의 첫 번째 요소를 제거하고, 제거된 요소를 반환한다.<br>
                    ex) 배열 [1,2,3]에 shift()를 사용하면 1을 반환하고 원래의 배열은 1이 제거된 [2,3]이 된다.<br>
                    변수 h에 hometown.shift()의 반환된 값을 할당하고 값이 유효한 경우 true, 아니면 false를 반환하고 이를 통해 반복문을 실행한다.</li>
                <li><span>19~20</span>변수 h에 할당된 객체에서 속성 name, place, city중 하나라도 없는 경우 continue로 다음 반복문으로 이동.</li>
                <li><span>22</span>변수 result에 h,'호석'을 인자값으로 받은 함수 isHometown의 결과를 할당</li>
                <li><span>23</span>result가 true면 break문으로 반복문 종료</li>
                <li><span>26~28</span>hometown의 배열에 새로 값을 추가 할 준비.</li>
                <li><span>29</span>do-while 반복문</li>
                <li><span>30</span>hometown 배열의 값에 0부터 객체값(name, city)을 할당.</li>
                <li><span>31</span>i값 1증가</li>
                <li><span>32</span>i가 4보다 작은 경우만 반복문 실행</li>
            </ol>
        </div>	
    </div>
	
	<h1>javascript 200제</h1>
    <div>
        <h2><span>초급 016</span>숫자형 이해하기</h2>
        <div class="content">
            <ul class="bull_list">
                <li><p>숫자형</p>숫자 형태를 가진 데이터</li>
            </ul>
            <script type="syntaxhighlighter" class="brush: js;">
            <![CDATA[
                3
                5.0
                2.789e5
            ]]>
            </script>
            <ul class="bull_list">
                <li>다른 프로그래밍 언어와 달리 숫자의 형태를 구체적으로 나눠서 정의하지 않고 정수, 부동 소숫점, 작은 수, 큰 수 등 여러 유형의 숫자를 숫자형(Number) 하나로 정의한다.</li>
                <li>64-bit Floating Point(64비트 부동 소수점)으로 국제 IEEE 754 표준에 따라 정의된 방식으로, 숫자값을 64 비트 정보로 저장한다.
                    <ul>
                        <li>숫자 : 비트 0~51에 저장</li>
                        <li>지수 : 비트 52~62에 저장</li>
                        <li>부호 : 비트 63에 저장</li>
                    </ul>
                </li>
            </ul>
        </div>
        <script type="syntaxhighlighter" class="brush: js;">
        <![CDATA[
            console.log(Infinity);              // Infinity
            console.log(1 / Infinity);          // 0
            console.log(0 / 0);                 // NaN      
            console.log(Infinity - Infinity);   // NaN      
            console.log(0 / "말도 안되는 값");   // NaN   
        ]]>
        </script>
        <div class="desc">
            <ul class="bull_list">
                <li><p>Infinity</p>
                    수학적으로 무한대를 의미하며, 어떤 수보다 가장 큰 수
                    <ul>
                        <li>console.log에서는 값 그대로 출력</li>
                        <li>Infinity로 나누면 무슨 값이든 0</li>
                    </ul>
                </li>
                <li><p>NaN(Not a number)</p>산술 연산의 결과가 유효하지 않은 값 또는 숫자가 너무 커서 표현할 수 없는 값</li>
            </ul>
            <ol>
                <li><span></span></li>
            </ol>
        </div>	
    </div>
    
    <div>
        <h2><span>초급 017</span>문자형 이해하기</h2>
        <div class="content">
            <ul class="bull_list">
                <li><p>문자형</p>값이 텍스트 형태인 데이터</li>
                <li>문자열로 표현 할 때에는 큰따옴표("), 작은따옴표('), 억음 부호(`)와 함께 사용하며 처음과 끝에 기호로 둘려싸인 형태로 작성되며 처음과 끝의 기호는 동일해야한다.</li>
            </ul>
        </div>
        <script type="syntaxhighlighter" class="brush: js;">
        <![CDATA[
            console.log("I'm in jeju");
            console.log('Sewha ocean is wonderful');
            console.log(`Have you ever eaten Makgeolli?`);
            console.log("This is the first line\nAnd this is the second"); // \n은 개행문자(줄바꿈)로 문자열의 줄바꿈을 한다. 
        ]]>
        </script>
    </div>
    
    <div>
        <h2><span>초급 018</span>불린형 이해하기</h2>
        <div class="content">
            <ul class="bull_list">
                <li><p>불린형(Boolean)</p>참(true)과 거짓(false) 값으로 이루어진 자료형</li>
            </ul>
        </div>
        <script type="syntaxhighlighter" class="brush: js;">
        <![CDATA[
            console.log(7 > 3);
            console.log(7 < 3);
        ]]>
        </script>
        <div class="desc">
            <ol>
                <li><span>1</span>숫자 7이 숫자 3보다 크다 : true 반환</li>
                <li><span>2</span>숫자 7이 숫자 3보다 작다 : false 반환</li>
            </ol>
        </div>	
    </div>
    
    <div>
        <h2><span>초급 019</span>null과 undefined 이해하기</h2>
        <div class="content">
            <ul class="bull_list">
                <li><p>null</p> 비어 있는, 존재하지 않는 값(원시자료형). typeof로 자료형 확인시 object를 반환하는 자바스크립트의 기존 이슈가 있다.</li>
                <li><p>undefined</p>변수가 정의 되었지만 아무 값도 할당받지 않은 상태(원시자료형)</li>
            </ul>
        </div>
        <script type="syntaxhighlighter" class="brush: js;">
        <![CDATA[
            var value = null;
            console.log(value);         // null
            console.log(typeof value);  // object
            var value;
            console.log(value);         // undefined
            console.log(typeof value);  // undefined              
        ]]>
        </script>
        <div class="desc">
            <ol>
                <li><span>1</span>변수 value에 null값 대입</li>
                <li><span>2</span>console.log로 출력하면 null 반환</li>
                <li><span>3</span>자료형 확인시 object를 반환(자바스크립트 기존 이슈 : 실제는 원시자료형)</li>
                <li><span>4</span>변수 value를 값을 할당하지 않고 선언</li>
                <li><span>5</span>아무 값이 없어서 undefined 출력</li>
                <li><span>6</span>자료형은 그대로 undefined 출력</li>
            </ol>
        </div>	
    </div>
    
    <div>
        <h2><span>초급 020</span>템플릿 문자형 이해하기</h2>
        <div class="content">
            <ul class="bull_list">
                <li>템플릿 문자열(Template String)은 ES6에서 추가되었다. </li>
            </ul>
        </div>
        <script type="syntaxhighlighter" class="brush: js;">
        <![CDATA[
            var cart = [
              { name: '옷', price: 2000 },
              { name: '가방', price: 1000 }
            ];
            var numOfItems = `카트에 ${cart.length}개의 아이템이 있습니다`;
            var cartTable = 
            `<ul>
              <li>품목: ${cart[0].name}, 가격: ${cart[0].price}</li>
              <li>품목: ${cart[1].name}, 가격: ${cart[1].price}</li>
            </ul>`
            console.log(numOfItems);    // 카트에 2개의 아이템이 있습니다
            console.log(cartTable);     // <ul>
                                        //     <li>품목: 옷, 가격: 2000</li>
                                        //     <li>품목: 가방, 가격: 1000</li>
                                        // </ul>
            var personName = 'harin';
            var helloString = 'hello ' + personName;            // hello harin
            var helloTemplateString = `hello ${personName}`;    // hello harin
            console.log(helloString === helloTemplateString);   // true
            console.log(typeof helloTemplateString);            // string
        ]]>
        </script>
        <div class="desc">
            <ol>
                <li><span>1~4</span>변수 cart에 name, price속성의 객체로 구성된 배열을 정의.</li>
                <li><span>5</span>
                    <div>cart.length의 값 2가 문자열에 삽입 된다.
                        <p>템플릿 문자열은 억음부호(`)와 ${표현식}을 이용해서 삽입 처리가 가능하다.</p>
                        <ul class="bull_list">
                            <li><p>삽입 처리</p>표현식의 계산된 결과가 문자열로 변경되어 해당 위치에 삽입되는 것</li>
                        </ul>
                    </div>
                </li>
                <li><span>6~10</span>템플릿 문자열은 코드 작성 시 개행해서 작성한 그대로 정의되어서 멀티 라인이 가능하다.</li>
                <li><span>11~15</span>콘솔로 출력</li>
                <li><span>16~17</span>문자열을 정의하고 두 문자열을 합한 결과를 helloString에 대입. </li>
                <li><span>18~20</span>같은 결과를 템플릿 문자열로 작성.<br>2가지 방식의 문자열 연산 결과값은 같고 템플릿 문자열의 결과값을 typeof로 확인하면 String(문자열)이다.</li>
            </ol>
        </div>	
    </div>
    
    <div>
        <h2><span>초급 021</span>산술 연산자</h2>
        <div class="content">
            <ul class="bull_list">
                <li>산술 연산자를 통해 숫자형 값 계산을 할수 있다. 덧셈 연산자의 경우 문자열을 이어 붙일 수 있다.</li>
            </ul>
            <script type="syntaxhighlighter" class="brush: js;">
            <![CDATA[
                10 + 5; // 15
                10 - 5; // 5
                10 * 5; // 50
                10 / 5; // 2
                "문자열" + " 이어 붙이기";  // 문자열 이어 붙이기
            ]]>
            </script>
        </div>
        
        <div class="content">
            <ul class="bull_list">
                <li>산술 연산자에 = 연산자를 함께 사용하는 산술 등호 연산이 가능 하다.</li>
            </ul>
            <script type="syntaxhighlighter" class="brush: js;">
            <![CDATA[
                var x = 10;
                x += 5;
                x *= 2;
                console.log(x);     // 30
                var y = 10;
                y -= 5;
                y /= 5;
                console.log(y);     // 1
            ]]>
            </script>
        </div>

        <div class="desc">
            <ol>
                <li><span>1</span>변수 x에 10 할당</li>
                <li><span>2</span>+= 연산은 x = x + 5로 처리 되어 x는 15</li>
                <li><span>3</span>*= 연산은 x = x * 5로 처리 되어 x는 30</li>
                <li><span>5</span>변수 y에 10 할당</li>
                <li><span>6</span>-= 연산은 y = y - 5로 처리 되어 y는 5</li>
                <li><span>7</span>/= 연산은 y = y / 5로 처리 되어 y는 1</li>
            </ol>
        </div>
        
        <script type="syntaxhighlighter" class="brush: js;">
            <![CDATA[
                console.log(15 % 4);    // 3
                console.log(3 ** 3);    // 27
                console.log(+10);       // 10
                console.log(-10);       // -10
                var value = 10;
                ++value;                // 11
                --value;                // 10
                console.log(value);     // 10
            ]]>
        </script>
        
        <div class="desc">
            <ol>
                <li><span>1</span>나머지 연산자(%) : 나누고 남은 값 반환.</li>
                <li><span>2</span>거듭제곱 연산자(**) : 거듭제곱 연산</li>
                <li><span>3~4</span>단항음수/양수(+/-) : 숫자 앞에 붙여서 양수, 음수로 변환</li>
                <li><span>6~7</span>증감 연산자(++/--) : 숫자 앞에 있으면 전치연산자로 증감을 먼저 실행, 뒤에 있으면 후치연산자로 증감을 나중에 한다.</li>
                <li><span>8</span>변수 value는 숫자 10을 할당하고 전치, 후치 연산을 한 결과 다시 10이 되었다.</li>
            </ol>
        </div>
    </div>
    
    <div>
        <h2><span>초급 022</span>비교 연산자</h2>
        <div class="content">
            <ul class="bull_list">
                <li><p>비교연산자</p>두 개의 값을 비교해서 true, false를 반환
                    <ul>
                        <li><p>일치 연산자</p>값이 동등한가</li>
                        <li><p>관계 연산자</p>값의 관계를 비교</li>
                    </ul>
                </li>
            </ul>
        </div>
        <script type="syntaxhighlighter" class="brush: js;">
        <![CDATA[
            console.log(5 == 5);        // true
            console.log("5" == 5);      // true
            console.log(5 == '5');      // true
            console.log(5 != 1);        // true
            console.log(5 != "1");      // true
            console.log(5 != "5");      // false
            console.log(5 === 5);       // true
            console.log(5 === "5");     // false
            console.log(5 !== 10);      // true
            console.log(5 !== "5");     // true    
        ]]>
        </script>
        
        <div class="desc">
            <ol>
                <li><span>1~3</span>동등 연산자(==)<br>자료형과 상관없이 값이 같은 경우 true(자료형이 다른경우 강제로 형을 바꾼뒤에 비교)</li>
                <li><span>4~6</span>부등 연산자(!=)<br>값이 다른경우 true(자료형이 다른경우 강제로 형을 바꾼뒤에 비교)</li>
                <li><span>7~8</span>일치 연산자(===)<br>값의 내용, 자료형까지 일치하면 true</li>
                <li><span>9~10</span>불일치 연산자(!==)<br>값의 내용 또는 자료형이 다른경우 true</li>
            </ol>
        </div>
        
        <script type="syntaxhighlighter" class="brush: js;">
        <![CDATA[
            console.log(5 > 3);                 // true
            console.log(5 < 3);                 // false
            console.log(5 <= 6);                // true
            console.log(5 >= 5);                // true
            console.log("Italy" > "America");   // true
            console.log("Korea" < "korea");     // true
        ]]>
        </script>
        
        <div class="desc">
            <ol>
                <li><span>1~4</span>
                    &gt;와 &lt;는 한쪽 값이 큰 경우 true<br>
                    &gt;=와 &lt;=는 한쪽 값이 크거나 동일한 경우 true
                </li>
                <li><span>5~6</span>문자열의 비교연산이 가능하다.(Unicode 기준으로 Binary를 통한 연산)<br>
                    알파벳 순서 뒷자리, 소문자쪽이 더 크다.
                </li>
            </ol>
        </div>
    </div>
    
    <div>
        <h2><span>초급 023</span>논리 연산자</h2>
        <div class="content">
            <ul class="bull_list">
                <li><p>논리 연산자</p>어떠한 명제에 대한 논리적인 판단을 내리는 연산자. 결과값은 Boolean형으로 반환</li>
            </ul>
        </div>
        
        <script type="syntaxhighlighter" class="brush: js;">
        <![CDATA[
            // AND 논리 연산자 &&
            console.log(true && true);                              // true
            console.log(true && false);                             // false
            console.log('문장' == '문장' && 5 == 5);                // true
            console.log(5 == 5 && '다른문장 1' == '다른문장 2');    // false

            // Or 논리 연산자 ||
            console.log(true || false);                 // true
            console.log(false || false);                // false
            console.log('문장' == '문장' || 5 == 10);    // true

            // Not 논리 연산자 !
            console.log(!true);         // false
            console.log(!false);        // true
            console.log(!5);            // false
            console.log(!'문장');       // false
            console.log(!!5);           // true
            console.log(!!'문장');      // true
        ]]>
        </script>
        <div class="desc">
            <ol>
                <li><span>2~3</span>AND 논리 연산자(&amp;&amp;)<br>모두 참인 경우 true</li>
                <li><span>4</span>양쪽이 같은 값으로 true</li>
                <li><span>5</span>문자형이 달라서 false</li>
                <li><span>8~10</span>or 논리 연산자(||)<br>둘 중 하나가 참인 경우 true</li>
                <li><span>13~14</span>not 논리 연산자(!)<br>!true = false<br>!false = true</li>
                <li><span>15~16</span>숫자형, 문자형은 항상 true. not 연산자(부정)를 사용하면 false를 반환</li>
                <li><span>17~18</span>not 연산자를 2번연속 사용하면 다시 원래의 값을 반환</li>
            </ol>
        </div>
        <div class="content">
            <ul class="bull_list">
                <li>boolean형이 아니어도 값이 유효한 경우 true를 반환<br>
                    3<br>
                    10<br>
                    '문자'<br>
                    true<br>
                    [1,2,3]<br>
                    {tom : 'boy'}<br>
                    function(){}
                </li>
                <li>값의 정보가 비어 있는 경우 false를 반환<br>
                    false<br>
                    0<br>
                    -0<br>
                    ""<br>
                    NaN<br>
                    null<br>
                    undefined
                </li>
            </ul>
        </div>
    </div>
    
    <div>
        <h2><span>초급 024</span> 삼항 연산자</h2>
        <div class="content">
            <ul class="bull_list">
                <li>조건문을 처리하는 연산자. if 조건문의 축약형으로 반드시 참, 거짓이 반환되어야 하며 참이면 표현식1을 거짓이면 표현식2를 실행한다.</li>
            </ul>
            <script type="syntaxhighlighter" class="brush: js;">
            <![CDATA[
                조건문 ? 표현문1 : 표현문2
            ]]>
            </script>
        </div>
        
        <div class="content">
            <ul class="bull_list">
                <li>삼항 연산의 결과로 반환된 값은 다시 변수로 할당할 수 있다.</li>
            </ul>
        </div>
        <script type="syntaxhighlighter" class="brush: js;">
        <![CDATA[
            var condition = 5 > 10;
            condition ? console.log('Left') : console.log('Right');     // Right
            var result = condition ? (
                console.log("삼항연산식의 첫번째 표현식 입니다."),
                "표현식1"
            ) : (
                console.log("삼항연산식의 두번째 표현식 입니다."),
                "표현식2"
            );
            console.log(result);    // 삼항연산식의 두번째 표현식 입니다.
                                    // 표현식2
        ]]>
        </script>
        <div class="desc">
            <ol>
                <li><span>1</span>연산 결과가 거짓이므로 false</li>
                <li><span>2</span>변수 condition의 값은 false이므로 console.log('Right')를 실행</li>
                <li><span>3~10</span>변수 result에 삼항 연산식을 대입한다.(결과값은 표현식2) </li>
                <li><span>10</span>변수 result(표현식2)를 출력</li>
            </ol>
        </div>	
    </div>
    
    <div>
        <h2><span>초급 025</span>비트 연산자</h2>
        <div class="content">
            <ul class="bull_list">
                <li><p>비트(Bit)</p>2진수(Binary digit)의 줄임말, 0과 1로 구성된 숫자 체계를 갖고 있는 2진수의 단일 값을 가진다. <strong>데이터의 가장 작은 기억장치의 최소 단위</strong></li>
                <li><p>바이트(Byte)</p><strong>컴퓨터 용량의 기본 단위</strong>로, 1byte = 8bit가 되며 이러한 비트를 활용한 연산이 비트연산자이다. 비트 연산은 숫자 0과 1로 구성된 2진수로 연산이 가능하다.<br>
                크게 <strong>비트 논리 연산자</strong>, <strong>비트 이동 연산자</strong>로 나뉜다.
                    <div>예제의 10진수를 2진수로 변환한 값<br>
                        1 = 1<br>
                        2 = 10<br>
                        11 = 1011<br>
                        14 = 1110
                    </div>
                </li>
            </ul>
            
        </div>
        <script type="syntaxhighlighter" class="brush: js;">
        <![CDATA[
            //예제의 10진수를 2진수로 변환한 값
            1 = 1
            2 = 10
            11 = 1011
            14 = 1110
            
            console.log(14 & 11);   // 10
            console.log(~14);       // -15
            console.log(14 | 11);   // 15
            console.log(14 ^ 11);   // 5
            console.log(2 << 2);    // 8
            console.log(14 >> 1);   // 7
            console.log(14 >>> 2);  // 3      
        ]]>
        </script>
        <div class="desc">
            <ol>
                <li><span>7</span><div><strong>AND 비트 연산자(&amp;)</strong><br>0이 하나라도 있으면 결과값이 0이 된다.<br>1110 &amp; 1011의 논리곱 연산의 결과 1010(10진수 10)을 출력</div></li>
                <li><span>8</span>
                    <div><strong>NOT 비트 연산자(~)</strong><br>입력한 반대의 값으로 바꾸어 연산.(~N = -(N+1)한 것과 같지만 비트 연산이 더 빠르다.)<br>~1110의 결과 -1111(10진수 -15)을 출력<br>
                        * 컴퓨터는 음수를 2의 보수법으로 표현한다.<br>
                        1의 보수(비트를 반전) +1 = 2의 보수<br>
                        1110의 1의 보수를 구하면 10001 + 1 = 1111(-15)이다. 최상위 비트(부호 비트)가 0이면 양수 1이면 음수를 의미
                    </div>
                </li>
                <li><span>9</span><div><strong>OR 비트 연산자(|)</strong><br>하나라도 1이면 1반환.<br>1110 | 1011의 결과값 1111(10진수 15)을 출력</div></li>
                <li><span>10</span><div><strong>XOR 비트 연산자(^)</strong><br>배타적 1인 경우에만 1을 반환<br>1110 ^ 1011의 결과값 0101(10진수 5)를 출력</div></li>
                <li><span>11</span><div><strong>&lt;&lt; 비트 연산자</strong><br>비트 자리수 만큼 왼쪽으로 이동하고 오른쪽은 0으로 채운다<br>10에서 왼쪽으로 2비트 이동한 값 1000(10진수 8)이 출력</div></li>
                <li><span>12</span><div><strong>&gt;&gt; 비트 연산자</strong><br>비트 자리수 만큼 오른쪽으로 이동하고 오른쪽의 남은 비트는 버린다<br>왼쪽의 빈자리는 원래 자리에 있던 값으로 채운다. 1110에서 오론쪽으로 1비트 이동한 값 111(10진수 7)을 출력</div></li>
                <li><span>13</span><div><strong>&gt;&gt;&gt; 비트 연산자</strong><br>비트 자리수 만큼 오른쪽으로 이동하고 오른쪽의 남은 비트는 버리고 왼쪽의 빈자리는 0으로 채움<br>1110에서 오른쪽으로 2비트 이동한 값 11(10진수 3)을 출력</div></li>
            </ol>
        </div>	
    </div>
    
    <div>
        <h2><span>초급 026</span>자료형 변환 이해하기</h2>
        <div class="content">
            <ul class="bull_list">
                <li><p>자료형 변환(type coercion, 형변환)</p>
                    자료형 간의 변환(ex : 숫자형 ↔ 문자형)을 의미하며 2가지 방법이 있다.<br>
                    <ul class="bull_list">
                        <li><p>명시적 자료형 변환</p>console, 내장 객체의 함수, 연산자를 사용</li>
                        <li><p>자바스크립트 엔진에 의해 자동 변환</p>동적 자료형 언어의 특징으로 자바스크립트의 정해진 규칙에 따라 자료형 변환 실행.</li>
                    </ul>
                </li>
            </ul>
        </div>
        <script type="syntaxhighlighter" class="brush: js;">
        <![CDATA[
            console.log("5" + 1);           // 51
            console.log("5" - 1);           // 4
            console.log("5" * 2);           // 10
            console.log("There is " + 5);   // There is 5
            console.log("Five" * 2);        // NaN

            console.log('- 연산자를 활용한 자료형 변환');
            var str = 5 + "1";              
            console.log(str);               // 51
            console.log(typeof str);        // string

            var num = +str;                 
            console.log(num);               // 51
            console.log(typeof num);        // number

            console.log('- 함수를 활용한 자료형 변환');
            str = String(num);              
            console.log(str);               // 51
            console.log(typeof str);        // string

            num = Number(str);
            console.log(num);               // 51
            console.log(typeof num);        // number
        ]]>
        </script>
        <div class="desc">
            <ol>
                <li><span>1~5</span>자동 형변환 될 때, 덧셈(+)연산자는 대입된 값에 따라 숫자형 또는 문자형으로 반환된다.</li>
                <li><span>8~10</span>숫자형 + 문자형 = 문자형 형변환되어서 51을 출력. 결과값의 자료형을 확인하면 문자형(덧셈 연산자는 숫자형보다 문자형이 우선됨을 의미.)</li>
                <li><span>12~14</span>단항 양수 +를 통해 문자형을 숫자형으로 변환</li>
                <li><span>17~23</span>내장 객체 함수를 이용한 명시적 형변환.<br>
                    String은 문자형,<br>
                    Number는 숫자형으로 변환된다.
                </li>
            </ol>
        </div>	
    </div>
    
    <div>
        <h2><span>초급 027</span>배열 이해하기</h2>
        <div class="content">
            <ul class="bull_list">
                <li>대괄호[]와 괄호 사이의 요소들로 구성되며, 요소들은 콤마(,)를 통해 구분. 자바스크립트는 동적 자료형 성격이어서 배열의 길이, 자료형은 고정되지 않는다.</li>
                <li>배열의 특정 위치의 요소로 접근 할 때에는 인덱스(Index)가 반드시 필요. 인덱스 값은 0부터 시작하며 1씩 증가한다.</li>
                <li></li>
            </ul>
            <script type="syntaxhighlighter" class="brush: js;">
            <![CDATA[
                []  // 빈배열
                [1, 2, 3, 4, 5]
                [1, 'A', true, null]
            ]]>
            </script>
        </div>
        <script type="syntaxhighlighter" class="brush: js;">
        <![CDATA[
            var arr = [1, 2, 3, 4, 5];
            console.log(arr.length);    // 5
            console.log(arr[0]);        // 1
            console.log(arr[2]);        // 3
            console.log(arr[8]);        // undefined
        ]]>
        </script>
        <div class="desc">
            <ol>
                <li><span>1</span>변수 arr에 배열을 대입</li>
                <li><span>2</span>배열의 length 속성은 배열의 길이를 숫자형으로 출력한다.</li>
                <li><span>3</span>배열 0번째 인덱스의 값을 출력</li>
                <li><span>4</span>배열 2번째 인덱스의 값을 출력</li>
                <li><span>5</span>배열의 인덱스 값이 없어서 undefined 출력 </li>
            </ol>
        </div>	
    </div>
    
    <div>
        <h2><span>초급 028</span>객체 이해하기 ①</h2>
        <div class="content">
            <ul class="bull_list">
                <li><p>원시 자료형</p>하나의 값을 저장</li>
                <li><p>객체(Object)</p>값들을 그룹으로 묶은 데이터 모음.<br>
                    중괄호 {}를 사용해서 그 안에 여러 값들을 넣을수 있는데 키(key)와 값(value) 한 쌍으로 정의하며 이를 속성(Properties)이라고 한다.<br>
                    하나의 키에는 하나의 값이 매핑되며 키는 중복 될수 없다. 두 줄 이상의 속성을 정의할 때는 콤마(,)로 구분한다.<br>
                    객체는 객체 속성으로 다른 객체와 함수 리터럴을 가질수 있다.
                </li>
            </ul>
        </div>
        <script type="syntaxhighlighter" class="brush: js;">
        <![CDATA[
            var family = {
              'address': 'Seoul',
              members: {},
              addFamily: function(age, name, role) {
                this.members[role] = {
                  age: age,
                  name: name
                };
              },
              getHeadcount: function() {
                return Object.keys(this.members).length;
              }
            };

            family.addFamily(30, 'chloe', 'aunt');
            family.addFamily(3, 'lyn', 'niece');
            family.addFamily(10, 'dangdangi', 'dog');
            console.log(family.getHeadcount());     // 3            
        ]]>
        </script>
        <div class="desc">
            <ol>
                <li><span>1</span>변수 family에 객체값을 할당하여 선언.</li>
                <li><span>2</span>키와 값을 객체에 추가.(키에는 따옴표를 유무에 따른 차이는 없다.)</li>
                <li><span>3</span>키 members에 값으로 객체 리터럴 대입</li>
                <li><span>4</span>키 addFamily에 값으로 함수 리터럴을 대입</li>
                <li><span>5~8</span>this 키워드로 addFamily의 member 속성에 접근하고 값을 할당(객체 선언후 속성을 추가적으로 더 넣을 수 있다.)</li>
                <li><span>10~12</span>키 getHeadcount에 함수 리터럴 할당. 이 함수는 member의 키를 모아 배열로 반환하고 그 길이를 알수 있다.</li>
                <li><span>15~17</span>객체의 속성 addFamily 함수를 호출하여 member를 추가</li>
                <li><span>18</span>객체의 속성 getHeadcount 함수를 호출하여 member에 추가된 개수를 출력</li>
            </ol>
        </div>	
    </div>
    
    <div>
        <h2><span>초급 029</span>객체 이해하기 ②(속성 접근/추가/수정/삭제)</h2>
        <div class="content">
            <ul class="bull_list">
                <li><p>객체 내부의 속성에 접근, 추가, 삭제하는 방법</p>
                    속성에 접근하려면 객체의 우측에 콤마를 두고 키 이름을 작성하면 된다.<br>
                    대괄호[] 안에 키 값을 문자열로 작성하는 방법도 있지만 콤마로 접근하는 방식이 선호된다.
                </li>
            </ul>
        </div>
        <script type="syntaxhighlighter" class="brush: js;">
        <![CDATA[
            var family = {
              'address': 'Seoul',
              members: {},
              addFamily: function(age, name, role) {
                this.members[role] = {
                  age: age,
                  name: name
                };
              },
              getHeadcount: function() {
                return Object.keys(this.members).length;
              }
            };

            family.addFamily(30, 'chloe', 'aunt');
            family.addFamily(3, 'lyn', 'niece');
            family.addFamily(10, 'dangdangi', 'dog');

            var printMembers = function() {
              var members = family.members;
              for (role in members) {
                console.log('role => ' + role + ', name => ' + members[role].name
                 + ', age => ' + members[role].age);
              }
            };
            printMembers();     // role => aunt, name => chloe, age => 30
                                // role => niece, name => lyn, age => 3
                                // role => dog, name => dangdangi, age => 10

            var members = family.members;
            members['nephew'] = { age: 3, name: 'hyun' };
            members.niece = { age: 5, name: 'lyn' }; 
            delete members.aunt;
            delete members['dog'];
            printMembers();     // role => niece, name => lyn, age => 5
                                // role => nephew, name => hyun, age => 3         
        ]]>
        </script>
        <div class="desc">
            <ol>
                <li><span>19</span>변수 printMembers에 함수 표현식 대입</li>
                <li><span>20</span>변수 member에 family의 키 member의 값을 할당</li>
                <li><span>21~23</span>for-in 반복문으로 객체의 member role, name, age를 출력 </li>
                <li><span>26</span>printMembers 함수 실행</li>
                <li><span>31</span>객체에 새로운 속성을 추가</li>
                <li><span>32</span>기존 객체의 속성 값 변경</li>
                <li><span>33~34</span>객체의 특정 속성 삭제 방법</li>
                <li><span>35</span>다시 printMembers를 실행하면 변경된 members의 값을 출력</li>
            </ol>
        </div>	
    </div>
	
	<h1>javascript 200제</h1>
    <div>
        <h2><span>초급 030</span>ES6의 향상된 객체 문법 알아보기 - 단축 속성명</h2>
        <div class="content">
            <ul class="bull_list">
                <li><p>단축 속성명</p>변수가 미리 준비되어 있는 경우, 변수명으로 속성의 키와 값을 한번에 정의할 수 있다.</li>
            </ul>
        </div>
        <script type="syntaxhighlighter" class="brush: js;">
        <![CDATA[
            var address = 'Seoul';
            var members = {};
            var addFamily = function(age, name, role) {
              this.members[role] = { age, name };
            };
            var getHeadcount = function() {
              return Object.keys(this.members).length;
            };

            var family = { address, members, addFamily, getHeadcount };

            family.addFamily(30, 'chloe', 'aunt');
            family.addFamily(3, 'lyn', 'niece');
            family.addFamily(10, 'dangdangi', 'dog');
            console.log(family.getHeadcount());             // 3
        ]]>
        </script>
        <div class="desc">
            <ol>
                <li><span>1~8</span>family 객체의 속성으로 사용할 변수를 작성 (변수명 = 속성의 키, 할당한 값 = 속성의 값)</li>
                <li><span>10</span>family 객체 리터럴을 선언하고 앞에서 정의한 변수들을 중괄호{} 안에 넣는다. 이 때 {변수명}으로 정의한 객체는 {변수명 : 변수값}으로 정의된 것과 동일하다.</li>
                <li><span>12~14</span>객체의 속성 addFamily 함수를 호출하고 member를 추가</li>
                <li><span>15</span>객체의 속성 getGeadcount 함수를 호출하고 member에 추가된 숫자를 출력</li>
            </ol>
        </div>	
    </div>
    
    <div>
        <h2><span>초급 031</span>ES6의 향상된 객체 문법 알아보기 - 속성 계산명</h2>
        <div class="content">
            <ul class="bull_list">
                <li><p>속성 계산명</p>대괄호[] 안에 식, 변수를 대입하여 동적으로 객체 속성들을 생성할 수 있다.</li>
            </ul>
        </div>
        <script type="syntaxhighlighter" class="brush: js;">
        <![CDATA[
            var obj = {};
            for (var i = 0; i < 4; i++) {
              obj['key' + i] = i;
            }
            console.log(obj);       // {key0: 0, key1: 1, key2: 2, key3: 3}

            var profile = 'chloe:30';
            var person = {
              [profile] : true,
              [profile.split(':')[0]]: profile.split(':')[1]
            };
            console.log(person);    // {chloe:30: true, chloe: "30"}            
        ]]>
        </script>
        <div class="desc">
            <ol>
                <li><span>1</span>변수 obj에 객체 대입</li>
                <li><span>2</span>0~3까지 반복하는 반복문 작성</li>
                <li><span>3</span>객체 obj에 속성 접근자[]를 사용해서 속성명을 정의</li>
                <li><span>5</span>객체를 출력하면 속성 접근자 안의 텍스트와 반복문에서 사용한 변수 i를 사용해서 객체값이 할당된다.</li>
                <li><span>7</span>변수 profile에 문자열 대입</li>
                <li><span>9</span>객체를 정의하면서 속성 계산명 사용. 속성의 키를 [profile]으로 선언해도 출력값은 "chloe:30"이다.</li>
                <li><span>10</span>.split(':')[0]은 ':'를 중심으로 나눈 왼쪽, [1]이면 오른쪽을 반환한다.</li>
                <li><span>12</span>객체를 출력하면 두번째 속성의 값이 .split의 결과값 chloe: "30"으로 변경되었다.</li>
            </ol>
        </div>	
    </div>
    
    <div>
        <h2><span>초급 032</span>ES6의 향상된 객체 문법 알아보기 - 비구조화 할당</h2>
        <div class="content">
            <ul class="bull_list">
                <li><p>비구조화 할당(Destructuring Assignment)</p>배열이나 객체의 값을 변수에 하나씩 일일히 할당하지 않고 ES6부터는 비구조화 할당으로 한번에 값을 할당할수 있다.</li>
                <li><p>객체 비구조화 할당</p>중괄호{} 안에 속성 이름을 넣어 객체의 속성을 한 번에 가져올수 있다.</li>
            </ul>
        </div>
        <script type="syntaxhighlighter" class="brush: js;">
        <![CDATA[
            var obj = { a: 1, b: 2, c: 30, d: 44, e: 5 };

            var { a, c } = obj;
            console.log(`a >>> ${a}`);          // a >>> 1
            console.log(`c >>> ${c}`);          // c >>> 30

            var { a:newA=10, f:newF=5 } = obj;
            console.log(`newA >>> ${newA}`);    // newA >>> 1
            console.log(`newF >>> ${newF}`);    // newF >>> 5            
        ]]>
        </script>
        <div class="desc">
            <ol>
                <li><span>3~5</span>객체 obj에 속성 a,b,c,d,e이 정의되어 있다. 중괄호 안에 원하는 속성명을 넣으면 객체의 해당 속성명 값을 변수 a, c에 할당한다. a = 1, c = 30이 된다.</li>
                <li><span>7~9</span>기존 속성의 값을 새로운 변수명으로 할당하여 정의할 수 있다. 형식은 구분자 ':'를 사이에 두고 왼쪽에는 속성명 오른쪽에는 새로운 변수명을 넣는다. 기본값을 설정할 수도 있다. a:newA=10은 객체의 a속성값을 새로운 변수 newA로 다시 할당해서 값이 없는 경우 undefind가 아닌 기본값으로 10을 할당한다는 의미. f는 없는 속성이어서 기본값 5 출력</li>
            </ol>
        </div>
        
        <div class="content">
            <ul class="bull_list">
                <li><p>배열 비구조화 할당</p>객체 비구조화와 같은 형식에 중괄호{} 대신 대괄호[]를 사용  </li>
            </ul>
        </div>
        <script type="syntaxhighlighter" class="brush: js;">
        <![CDATA[
            var arr = [ 1, 2, 30, 44, 5 ];

            var [b, c, ...rest] = arr;
            console.log(`0) b >>> ${b}`);           // 0) b >>> 1
            console.log(`0) c >>> ${c}`);           // 0) c >>> 2
            console.log(`0) rest >>> ${rest}`);     // 0) rest >>> 30,44,5

            var [a=10, f=9] = [1];
            console.log(`1) a >>> ${a}`);           // 1) a >>> 1
            console.log(`1) f >>> ${f}`);           // 1) f >>> 9

            [a, f] = [f, a];
            console.log(`2) a >>> ${a}`);           // 2) a >>> 9
            console.log(`2) f >>> ${f}`);           // 2) f >>> 1

            function getArr() {
              return [1, 2, 3, 4, 5, 6];
            }
            [a, , , , , f] = getArr();
            console.log(`3) a >>> ${a}`);           // 3) a >>> 1
            console.log(`3) f >>> ${f}`);           // 3) f >>> 6
        ]]>
        </script>
        <div class="desc">
            <ol>
                <li><span>4~6</span>배열 arr에 숫자형 요소 5개가 대입되어 있고 변수 b, c, rest(나머지 값)에 배열 arr 요소의 값을 할당.</li>
                <li><span>8~14</span>배열 비구조화의 기본값 설정. 배열 [1]을 비구조화해서 변수 a, f에 할당하면 f는 값이 없으므로 기본값 9 출력</li>
                <li><span>16~21</span>함수에서 반환된 배열값을 비구조화 할 수 있고, 일부 배열 요소를 무시하고 원하는 배열 요소만 가져오는 것도 가능하다.<br>
                    19번 라인처럼 중간 4개 요소를 반환받고 싶지 않다면 공백으로 비워두면 된다.
                </li>
            </ol>
        </div>	
    </div>
    
    <div>
        <h2><span>초급 033</span>심볼형 이해하기</h2>

        <script type="syntaxhighlighter" class="brush: js;">
        <![CDATA[
            const symbol = Symbol();
            const hello = Symbol('hello');

            console.log(Number(3) === Number(3));                   // true
            console.log(Symbol('symbol') === Symbol('symbol'));     // false
            console.log(Symbol() === Symbol());                     // false
            console.log(typeof Symbol());                           // symbol

            const nationility = Symbol('nationility');
            const user = {
              name: 'jay'
            };
            user[nationility] = 'korean';
            console.log(user[nationility]);                         // korean

            for (let key in user) {
             console.log(key);                                      // name
            }
            console.log(Object.keys(user));                         // ["name"]
            console.log(Object.getOwnPropertyNames(user));          // ["name"]
            console.log(JSON.stringify(user));                      // {"name":"jay"}

            const symbolProperties = Object.getOwnPropertySymbols(user);
            console.log(symbolProperties);                          // [Symbol(nationility)]
            console.log(user[symbolProperties[0]]);                 // korean
        ]]>
        </script>
        <div class="desc">
            <ol>
                <li><span>1</span>Symbol은 함수 호출을 통해 생성 가능해서 new 키워드를 통한 호출 new Symbol() 시 에러 발생</li>
                <li><span>2~7</span>Symbol은 함수 호출 시 값을 전달할 수 있다.(디버깅 용도) Symbol은 각자 고유한 값을 반환해서 Symbol끼리 값을 비교하면 false를 반환한다. typeof로 자료형 확인시 Symbol 출력</li>
                <li><span>9~14</span>Symbol은 객체의 키로 사용 가능하다. 객체의 키로 사용하기 위해선 Symbol에 대한 레퍼런스를 변수에 담고 있다가 접근할 때마다 사용해야한다.</li>
                <li><span>16~18</span>Symbol이 객체의 키로 사용되었다면 for-in 루프를 통해 Symbol키를 가져올수 없다.</li>
                <li><span>19~21</span>그래서 Object의 키를 반환하는 메소드를 사용하거나 JSON 문자열로 만들어도 Symbol키는 없다.</li>
                <li><span>23~25</span>Object.getOwnPropertySymbols 메소드를 통해 해당 객체의 Symbol키를 가져올수 있다.</li>
            </ol>
        </div>	
    </div>
    
    <div>
        <h2><span>초급 034</span>함수 이해하기</h2>
        <div class="content">
            <script type="syntaxhighlighter" class="brush: js;">
                <![CDATA[
                    function 함수 이름 (매개변수 목록) {
                        함수 실행부
                    }
                ]]>
            </script>
            <dl>
                <dt>함수의 형태</dt>
                <dd>
                    <ul class="bull_list">
                        <li><p>키워드 function</p>함수 자료형은 키워드 function을 앞에 붙여 함수로 정의하는데 ES6부터는 function 없이 함수로 정의할 수 있다.(47장)</li>
                        <li><p>함수 이름</p>function과 소괄호() 사이에 이름을 정의하여 함수를 식별한다. 함수 내에서 재귀로 자신을 참조할 수도 있고 이름을 정의하지 않은 익명 함수도 있다. </li>
                        <li><p>매개변수 목록</p>함수 이름 옆에 소괄호()로 둘러싸인 부분으로 함수 선언 시 매개변수을 정의하면 함수 호출 시 인자값을 전달할 수 있다. 함수 안에서 전역 변수로 처리할 수 있지만, 매개변수 사용을 권장.(36장, 39장)</li>
                        <li><p>함수 실행부</p> 함수가 호출되면 실행되는 부분으로 중괄호{} 안에 코드를 작성한다.</li>
                    </ul>
                </dd>
                <dt>함수를 만드는 방식</dt>
                <dd>
                    <ul class="bull_list">
                        <li><p>함수 표현식</p>함수를 정의하면서 변수에 바로 할당.</li>
                        <li><p>함수 선언문</p>함수 이름으로 선언</li>
                    </ul>
                </dd>
            </dl>
            <p>많은 양의 코드를 연관 있는것 끼리 정리해서 함수로 만들면 코드를 보기 좋게 정리하면서 중복 코드를 줄이는 코드의 재사용을 할 수 있다.</p>
        </div>
        <script type="syntaxhighlighter" class="brush: js;">
        <![CDATA[
            var greeting_expression = function(name) {
                console.log('Hi, ' + name);
            }

            function greeting_declaration(name) {
                console.log('Hi, ' + name);
            }

            greeting_expression('Chloe');   // Hi, Chloe
            greeting_declaration('Chloe');  // Hi, Chloe            
        ]]>
        </script>
        <div class="desc">
            <ol>
                <li><span>1~3</span>함수 표현식 함수 생성. 변수 greeting_expression에 함수 리터럴 할당</li>
                <li><span>5~7</span>함수 선언문 함수 생성. 함수명(greeting_declaration)으로 선언</li>
                <li><span>9~10</span>함수 호출할 때는 함수 리터럴이 할당된 변수 이름 또는 함수 선언문의 함수 이름이 필요하다. 함수 표현식에서 정의한 함수 이름은 해당 함수 안에서만 호출이 가능하다. 선언된 함수가 매개변수가 필요할 경우 소괄호()안에 전달할 값을 나열한다.</li>
            </ol>
        </div>	
    </div>
    
    <div>
        <h2><span>초급 035</span>예외 처리하기</h2>
        <div class="content">
            <ul class="bull_list">
                <li>자바스크립트 코드 실행중 에러가 발생하면 즉시 중단되는데 이를 대비해서 예외 처리는 반드시 필요하다. 예외 처리 방법으로 <strong>throw문</strong>과 <strong>try-catch-finally문</strong>이 있다.</li>
                <li>예외 처리 시 에러 종류는 크게 두 가지로 예상치 못한 에러, 개발자가 의도한 에러(코드에서 잘못될 가능성을 예상하고 발생시키는 에러)가 있는데 후자의 경우 <strong>throw문</strong>을 사용한다. <strong>throw문</strong>은 고의로 에러를 발생 시켜 예외 상황을 알리고 <strong>throw문</strong> 실행 후 블록을 빠져나간다.</li>
            </ul>
        </div>
        <script type="syntaxhighlighter" class="brush: js;">
        <![CDATA[
            function checkNumber(val) {
              if (typeof val !== 'number') throw '유효하지 않은 값입니다.';
              console.log('숫자형 값으로 확인되었습니다.');
            }

            checkNumber(100);
            checkNumber('Wrong type');
            console.log('완료');            
        ]]>
        </script>
        <div class="desc">
            <ol>
                <li><span>1</span>숫자형 값 여부를 확인하는 함수를 선언</li>
                <li><span>2</span>typeof val로 매개변수가 숫자형 값이 아닌경우 throw문을 통해 함수 블록을 빠져나간다.</li>
                <li><span>3</span>숫자형일 경우 출력되는 문장</li>
                <li><span>6</span>함수의 인자값으로 숫자형 값을 입력하면 3라인의 console을 출력</li>
                <li><span>7</span>함수의 인자값으로 문자형 값을 입력하면 숫자형 값이 아니어서 2라인의 throw문 실행</li>
                <li><span>8</span>7라인에서 에러 발생하여 코드 실행이 중단되어 8라인은 실행되지 않음</li>
            </ol>
        </div>
        
        <div class="content">
            <ul class="bull_list">
                <li><strong>throw문</strong>은 예외 상황을 미리 파악해서 에러를 발생시켜 이후 코드를 실행되지 않도록 하지만 프로그램이 중단되는 것은 막을수 없는데 대응책으로 try-catch-finally문을 사용하면 예상치 못한 에러와 개발자가 의도한 에러 모두 대응 가능하다.</li>
                <li><strong>try-catch-finally문</strong>은 try 블록에서 발생된 에러를 잡아내고, catch 블록으로 제어권을 넘긴다. try 블록에서 발생된 에러 정보는 catch 문의 변수로 전달되기 때문에, 개발자는 프로그램 종료 없이 어떤 에러가 발생했는지 확인할 수 있다. finally 블록은 에러 발생 여부와 상관없이 실행된다. </li>
            </ul>
        </div>
        <script type="syntaxhighlighter" class="brush: js;">
        <![CDATA[
            function checkNumber(val) {
              if (typeof val !== 'number') throw '유효하지 않은 값입니다.';
              console.log('숫자형 값으로 확인되었습니다.');
            }

            try {
              checkNumber(100);
              checkNumber('Wrong type');
            } catch (e) {
              console.log(`에러가 발생했습니다 >>> ${e}`);   // 에러가 발생했습니다 >>> 유효하지 않은 값입니다.
            } finally {
              console.log('완료');
            }
        ]]>
        </script>
        <div class="desc">
            <ol>
                <li><span>1~3</span>숫자형 값 여부를 확인하는 함수를 선언</li>
                <li><span>6~8</span>try문의 블록에서 에러가 발생했기 때문에 에러 정보는 catch 블록으로 전달된다.</li>
                <li><span>9~10</span>변수 e에 에러 정보('유효하지 않은 값입니다.')가 전달되어 "에러가 발생했습니다 &gt;&gt;&gt; 유효하지 않은 값입니다."를 출력</li>
                <li><span>11~12</span>10라인까지의 코드를 실행한 후에 finally는 에러 여부와 상관없이 실행되기 때문에 '완료'를 출력 </li>
            </ol>
        </div>
    </div>
    
    <div>
        <h2><span>초급 036</span>arguments 객체 이해하기</h2>
        <div class="content">
            <ul class="bull_list">
                <li><p>매개변수</p>함수 선언 시 작성되는 변수</li>
                <li><p>전달 인자(argument)</p>함수가 호출될 때 전달되는 값</li>
                <li>전달 인자와 매개변수의 개수가 달라도 에러 발생하지 않아서 매개변수와 무관하게 함수 호출 시 더 많은 인자를 전달할 수 있다.</li>
                <li><p>arguments객체</p>매개변수 외에 함수에서만 사용 가능한 특별한 객체</li>
            </ul>
        </div>
        <script type="syntaxhighlighter" class="brush: js;">
        <![CDATA[
            function sum() {
              var total = 0;
              for (var i = 0; i < arguments.length; i++) {
                total += arguments[i];
              }
              console.log(arguments instanceof Array);      // false
              return total;
            }

            var sumOf1to3 = sum(1, 2, 3);
            console.log(sumOf1to3);                         // 6

            function testArg() {
              var newArr = Array.prototype.slice.call(arguments);
              console.log(newArr);                          // ["a", "b"]
              console.log(newArr.indexOf('b'));             // 1
              console.log(arguments.indexOf('b'));          // Uncaught TypeError: arguments.indexOf is not a function
            }

            testArg('a', 'b');            
        ]]>
        </script>
        <div class="desc">
            <ol>
                <li><span>1~8</span>함수 sum을 정의하면서 arguments 객체를 통해 전달된 인자의 합을 반환한다.</li>
                <li><span>6</span>instanceof 연산자를 이용하여 arguments 객체는 배열이 아님을 확인할 수 있다.</li>
                <li><span>10~11</span>함수 sum는 매개변수를 정의하지 않았지만, 전달인자 1,2,3이 있어도 에러가 발생하지 않고 결과값 6을 출력</li>
                <li><span>14~15</span>프로토타입에 정의된 slice 메소드를 호출하면 arguments 객체의 요소들을 복사하는 새로운 배열이 생성된다.</li>
                <li><span>16</span>배열이기 때문에 indexOf 메소드를 사용하여 문자열 b인 인덱스 값(1)을 반환한다.</li>
                <li><span>17</span>arguments 객체는 배열이 아니기 때문에 에러 발생</li>
            </ol>
        </div>	
    </div>
    
    <div>
        <h2><span>초급 037</span>함수 기본 매개변수 처리하기</h2>
        <div class="content">
            <ul class="bull_list">
                <li><p>기본 매개변수</p>ES6에 추가된것으로 매개변수를 정의할 때 기본으로 할당될 인자값과 함께 작성하는 매개변수. 값을 할당하는 '='로 정의</li>
            </ul>
        </div>
        <script type="syntaxhighlighter" class="brush: js;">
        <![CDATA[
            function drawChart(width = 200, height = 400) {
              console.log(`${width} X ${height} 차트를 그립니다.`);
            }
            drawChart(100);     // 100 X 400 차트를 그립니다.
            drawChart();        // 200 X 400 차트를 그립니다.

            function drawChart2(width = 200, height = width / 2) {
              console.log(`${width} X ${height} 차트를 그립니다.`);
            }
            drawChart2(300);    // 300 X 150 차트를 그립니다.
            drawChart2();       // 200 X 100 차트를 그립니다.            
        ]]>
        </script>
        <div class="desc">
            <ol>
                <li><span>1~3</span>함수 drawChart를 정의하면서 기본 매개변수로 width, height를 선언한다. 전달 인자가 없다면 기본값으로 선언한 200, 400을 할당한다.</li>
                <li><span>4</span>함수 실행시 전달 인자가 하나뿐이라 width에는 100이 할당되고 height에는 기본값인 400이 할당된다.</li>
                <li><span>5</span>전달 인자가 없어서 미리 선언된 기본값 200, 400 할당</li>
                <li><span>7~9</span>다른 매개변수를 기본 매개변수로 선언할 수 있다.</li>
                <li><span>10</span>인자값이 하나뿐이어서 width에 300이 할당되고 height에는 width/2값 150이 할당된다.</li>
                <li><span>11</span>전달 인자가 없어서 200, 100 할당된다.</li>
            </ol>
        </div>	
    </div>
    
    <div>
        <h2><span>초급 038</span>함수 나머지 매개변수 이해하기</h2>
        <div class="content">
            <ul class="bull_list">
                <li>ES6에서 새로 추가되었으며, 매개변수를 정의할 때 정해지지 않은 매개변수들을 정의할 수 있게 한다.
                    <ul class="bull_list">
                        <li><p>arguments 객체</p>함수에 전달하는 모든 전달 인자를 포함(배열이 아니다.)</li>
                        <li><p>나머지 매개변수</p>정해지지않은 나머지를 의미(배열이다.)</li>
                    </ul>
                </li>
            </ul>
            <script type="syntaxhighlighter" class="brush: js;">
            <![CDATA[
                function(parameter, ...restParameter){
                    // arguments 객체는 나머지 매개변수와 다르게 함수 몸통에서만 사용
                }
            ]]>
            </script>
            <p></p>
        </div>
        <script type="syntaxhighlighter" class="brush: js;">
        <![CDATA[
            function sum(...args) {
              var total = 0;
              for (var i = 0; i < args.length; i++) {
                total += args[i];
              }
              console.log(args.indexOf(1))
              return total;
            }
            console.log(sum(1, 2, 3));  // 0, 6

            function sum2(a, b, ...others) {
              var total = a + b;
              for (var i = 0; i < others.length; i++) {
                total += others[i];
              }
              return total;
            }
            console.log(sum2(1, 2));        // 3    (others.length = 0)
            console.log(sum2(1, 2, 3, 4));  // 10   (others.length = 2)
        ]]>
        </script>
        <div class="desc">
            <ol>
                <li><span>1~9</span>함수 sum은 나머지 매개변수로 정의한다. 나머지 매개변수는 배열이어서 [index]를 통해 접근 하거나 indexOf 같은 메소드를 사용할 수 있다.<br>
                    9라인의 전달 인자(1,2,3)는 args의 배열 요소가 되고 순차적으로 변수 total의 값과 더한 값을 다시 변수 total에 대입해서 총합계를 구하게 된다.</li>
                <li><span>11~17</span>함수 sum2는 매개변수 a,b와 나머지 매개변수 other를 정의하고 있다.</li>
                <li><span>18</span>매개변수 a,b에 전달 인자 1,2가 전달 되고 others는 빈 배열이 된다.</li>
                <li><span>19</span>매개변수 보다 전달 인자가 많아서 a,b에는 1,2가 전달되고 나머지 3,4는 others의 나머지 매개변수의 배열 요소가 전달 된다.</li>
            </ol>
        </div>	
    </div>
    
    <div>
        <h2><span>초급 039</span>스코프 이해하기</h2>
        <div class="content">
            <ul class="bull_list">
                <li><p>스코프</p>변수, 매개변수가 어디까지 유효한지를 나타내는 것.</li>
                <li><p>함수 스코프</p>함수 내부에서 선언된 변수는 함수 블록 안에서만 접근할 수 있다.</li>
                <li><p>전역 스코프</p>함수 외부에서 선언된 변수는 코드 어디에서든 접근할 수 있다.</li>
            </ul>
        </div>
        <script type="syntaxhighlighter" class="brush: js;">
        <![CDATA[
            var a = 10;
            console.log(a);     // 10

            function print() {
              var b = 20;
              if (true) {
                var c = 30;
              }
              console.log(c);   // 30
            }

            print();
            console.log(b);     // Uncaught ReferenceError: b is not defined
        ]]>
        </script>
        <div class="desc">
            <ol>
                <li><span>1~2</span>변수 a를 선언하고 10을 대입하고 값을 console로 출력</li>
                <li><span>4</span>함수 print 선언</li>
                <li><span>5</span>함수 내부에서 변수 b를 선언하고 20을 대입</li>
                <li><span>6~9</span>함수 내부에서 var 키워드로 선언한 변수는 함수 스코프에 정의되어 함수 내부에서만 접근할 수 있다.</li>
                <li><span>13</span>변수 b의 값을 출력하려고 해도 함수 스코프에 정의되어 함수 외부에서 접근할 수 없고, 전역 스코프에도 변수 b가 없기 때문에 에러 출력</li>
            </ol>
        </div>
        
        <script type="syntaxhighlighter" class="brush: js;">
        <![CDATA[
            var a = "global";

            function print1() {
              console.log(a);
            }

            function print2() {
              var a = "local";
              print1();
            }

            print1();   // global
            print2();   // global
        ]]>
        </script>
        <div class="content">
            <ul class="bull_list">
                <li>스코프는 렉시컬(Lexical) 스코프, 다이나믹(Dynamic) 스코프로 분류된다. 렉시컬 스코프는 코드를 작성하는 시점에 스코프가 결정되어 정적 스코프라고도 한다. 자바스크립트는 대표적 렉시컬 스코프이다.</li>
                <li>위 코드의 결과는 모두 global을 출력한다. 자바스크립트가 다이나믹 스코프였다면 global, local이 출력되었을 것이다.</li>
            </ul>
        </div>
        <div class="desc">
            <ol>
                <li><span>1~5</span>젼역으로 변수 a, 함수 print를 선언. 변수 a에는 문자열 global 대입</li>
                <li><span>7~10</span>함수 print2 내부에 변수 a를 정의하고 문자열 local 대입하고 함수 print1 호출</li>
                <li><span>12</span>print1 함수 호출. 변수 a가 함수 스코프에 없고 전역 스코프에서 찾아서 global 출력</li>
                <li><span>13</span>print2 함수 호출. 함수 내부에서 함수 print1을 호출한다. 이때 변수 a를 전역, 내부 어디에서 찾을지가 렉시컬 스코프와 다이나믹 스코프는 다르게 해석한다. 자바스크립트는 렉시컬 스코프이기 때문에 코드를 작성하는 시점에 확정되므로 함수 print1이 호출될 때에 전역 a를 참조해서 문자열 global을 출력한다.</li>
            </ol>
        </div>
    </div>
    
    <div>
        <h2><span>초급 040</span>함수 호이스팅 이해하기</h2>
        <div class="content">
            <ul class="bull_list">
                <li><p>호이스팅(Hoisting 끌어 올리기)</p>ECMAScript® 2015(ES6)언어 명세 및 그 이전 표준 명세에서 사용된 적이 없는 용어로 호이스팅이 변수 및 함수 선언이 물리적으로 작성한 코드의 상단으로 끌어 올리는 것이라고 하지만, 실제는 변수 및 함수 선언은 컴파일 단계에서 메모리에 저장되지만, 코드에서 입력한 위치와 정확히 일치한 곳에 있다.</li>
                <li>다른 언어에서는 변수 선언없이 출력하면 오류가 발생하지만 자바스크립트는 undefined를 할당하고 다음으로 넘어 간다.</li>
                <li>선언문을 최우선으로 해석하고, 할당 구문은 런타임 과정에서 이루어지므로 호이스팅 하지 않는다.</li>
            </ul>
            <script type="syntaxhighlighter" class="brush: js;">
            <![CDATA[
                // 자바스크립트는 코드 구분을 실행 전 함수 선언을 메모리에 저장하기 때문에 코드에서 선언하기 전에도 함수를 사용할 수 있다.
                catName("Chloe");
                function catName(name) {
                  console.log("My cat's name is " + name);  // My cat's name is Chloe
                }
            ]]>
            </script>
            
            <ul class="bull_list">
                <li>호이스팅은 다른 데이터 타입, 변수와도 잘 작동한다. 변수는 선언 전에 초기화하여 사용될 수 있지만 초기화 없이는 사용할 수 없다.</li>
            </ul>
            <script type="syntaxhighlighter" class="brush: js;">
            <![CDATA[
                num = 6;
                num + 7;
                var num;    //num이 선언되지 않아도 에러가 발생 하지 않는다
            ]]>
            </script>
            
            <ul class="bull_list">
                <li>자바스크립트는 초기화가 아닌 선언만 끌어올린다(hoist). 변수를 선언한 뒤 나중에 초기화하면 undefined가 할당</li>
            </ul>
            <script type="syntaxhighlighter" class="brush: js;">
            <![CDATA[
                // 두 예제 모두 undefined
                var x = 1;      // 초기화
                console.log(x + " " + y);   // '1 undefined'
                var y = 2;

                var x = 1;      // 초기화
                var y;          // 선언
                console.log(x + " " + y);   // '1 undefined'
                y = 2;          // 초기화
            ]]>
            </script>
        </div>
        
        <script type="syntaxhighlighter" class="brush: js;">
        <![CDATA[
            hello(); // 안녕하세요
            function hello() {
              console.log("안녕하세요");
            }

            hello2(); // Uncaught TypeError: hello is not a function
            var hello2 = function () {
              console.log("안녕하세요");
            }          
        ]]>
        </script>
        <div class="desc">
            <ol>
                <li><span>1~4</span>함수 선언문으로 함수를 호출했다. 실행 전 함수 선언은 컴파일 단계에서 메모리에 저장되기 때문에 코드 선언 전에도 '안녕하세요' 출력</li>
                <li><span>6</span>함수 표현식(함수를 정의하면서 변수에 할당)으로 함수를 호출하면 TypeError가 발생한다. 함수 호이스팅은 함수의 선언은 끌어올리지만 변수의 값(할당)은 끌어 올리지 않기 때문이다. 변수 hello2는 호이스팅이 이루어져서 undefined를 할당되었고 undefined는 호출할 수 없기 때문에 TypeError가 발생한 것이다. 호이스팅이 이루어지지 않았다면 ReferenceError가 발생해야 한다.</li>
            </ol>
        </div>
    </div>
    
    <div>
        <h2><span>초급 041</span>let으로 변수 선언하기</h2>
        <div class="content">
            <ul class="bull_list">
                <li>let은 변수가 선언된 블록, 구문 또는 표현식 내에서만 유효한 변수를 선언한다. var 키워드가 블록 범위를 무시하고 전역 변수, 함수 지역 변수로 선언되는 것과 다르다.</li>
            </ul>
            
            <ul class="bull_list">
                <li><p>유효 범위 규칙</p>let 으로 선언된 변수는 변수가 선언된 블록 내에서만 유효하며, 하위 블록에서도 유효하다. var는 함수 블록 이외의 블록은 무시하고 선언된다는 점이 다르다.</li>
            </ul>
            <script type="syntaxhighlighter" class="brush: js;">
            <![CDATA[
                function varTest() {
                  var x = 1;
                  if (true) {
                    var x = 2;      // 상위 블록과 같은 변수!
                    console.log(x); // 2
                  }
                  console.log(x);   // 2
                }

                function letTest() {
                  let x = 1;
                  if (true) {
                    let x = 2;      // 상위 블록과 다른 변수
                    console.log(x); // 2
                  }
                  console.log(x);   // 1
                }
            ]]>
            </script>
            
            <ul class="bull_list">
                <li>프로그램이나 함수의 최상위에서 let은 전역 객체의 속성 값을 생성하지 않는다.</li>
            </ul>
            <script type="syntaxhighlighter" class="brush: js;">
            <![CDATA[
                var x = 'global';
                let y = 'global';
                console.log(this.x); // "global" 전역 객체의 속성 x를 생성
                console.log(this.y); // undefined 전역 객체의 속성 y를 생성하지 않음
            ]]>
            </script>
            
            <ul class="bull_list">
                <li><p>임시적인 사각 지역과 오류</p>같은 변수를 같은 함수나 블록 범위 내에서 재선언하면 SyntaxError 발생</li>
            </ul>
            <script type="syntaxhighlighter" class="brush: js;">
            <![CDATA[
                if (x) {
                  let foo;
                  let foo; // SyntaxError thrown.
                }
            ]]>
            </script>
            
            <ul class="bull_list">
                <li>let은 선언 끌어올리기의 적용을 받지 않아서 변수가 초기화(선언)되기 전에 참조하면 ReferenceError가 발생합니다.(var로 선언된 변수의 경우 undefined 값을 가짐) "임시적인 사각 지역"은 블록 시작 부분부터 변수 선언이 실행되기 전까지를 말한다. (let의 정의가 평가되기까지 초기화가 되지 않는다는 의미이며, 호이스팅이 되지않아 정의가 되지 않는다는 의미와는 다르다)</li>
            </ul>
            <script type="syntaxhighlighter" class="brush: js;">
            <![CDATA[
                function do_something() {
                  console.log(bar); // undefined
                  console.log(foo); // ReferenceError
                  var bar = 1;
                  let foo = 2;
                }
            ]]>
            </script>
        </div>
        
        <script type="syntaxhighlighter" class="brush: js;">
        <![CDATA[
            if (true) {
              var functionScopeValue = 'global';
              let blockScopeValue = 'local';
            }
            console.log(functionScopeValue);    // global
            console.log(blockScopeValue);       // Uncaught ReferenceError: blockScopeValue is not defined
        ]]>
        </script>
        <div class="desc">
            <ol>
                <li><span>1~4</span>if문 블록 안에 각각 var, let 키워드로 변수 선언</li>
                <li><span>5</span>var 키워드로 정의한 변수는 함수 단위 유효범위를 가지게 되어 블록 외부에서 접근 가능</li>
                <li><span>6</span>let 키워드로 정의한 변수는 블록 단위 유효범위를 가지게 되어 블록 외부에서 접근할 경우 ReferenceError 발생</li>
            </ol>
        </div>
        
        <script type="syntaxhighlighter" class="brush: js;">
        <![CDATA[
            let value = "바깥값";
            if (true) {
              console.log(value);   // Uncaught ReferenceError: Cannot access 'value' before initialization
              let value = "안쪽값";
            }            
        ]]>
        </script>
        <div class="desc">
            <ol>
                <li><span>1~5</span>let으로 선언한 변수는 블록 단위로 일어나지만 var와 다르게 undefined를 할당하지 않고 블록의 시작부터 선언이 이루어진 라인까지 일시적으로 접근을 막는다.<br>
                    4라인이 없었다면 전역에서 정의된 value를 참조하여 "바깥값"을 출력하게 되지만 if문 블록 안에서 let으로 변수를 정의하였기 때문에 value는 if 블록문의 위쪽으로 호이스팅 되어 실제 let으로 선언이 이루어지기 전까지 일시적으로 접근이 안되는 영역을 만들고 그 안에서 접근을 하면 에러가 발생한다.</li>
            </ol>
        </div>	
    </div>
    
    <div>
        <h2><span>초급 042</span>const로 상수 선언하기</h2>
        <div class="content">
            <ul class="bull_list">
                <li>블록 범위의 상수를 선언한다. 선언 시 값을 할당해야 하고 재할당, 다시 선언할 수 없다. </li>
                <li>상수는 let 문을 사용하여 정의된 변수와 마찬가지로 블록 범위(block-scope)이다.</li>
                <li>let에 적용한 "일시적 사각 지대"에 관한 모든 고려는, const에도 적용된다.</li>
                <li>상수는 같은 범위의 상수 또는 변수와 그 이름을 공유할 수 없습니다.</li>
            </ul>
        </div>
        <script type="syntaxhighlighter" class="brush: js;">
        <![CDATA[
            const URL = 'http://js.com';
            URL = 'http://js.com';      // Uncaught TypeError: Assignment to constant variable.

            if (true) {
              const URL2 = 'http://js.com'; 
            }

            console.log(URL2);          // Uncaught ReferenceError: URL2 is not defined         
        ]]>
        </script>
        <div class="desc">
            <ol>
                <li><span>2</span>const로 정의된 상수에 재할당을 하면 Uncaught TypeError: Assignment to constant variable. 에러가 발생한다. const를 관례적으로 변하지 않는 값을 정의하기 때문에 대문자로 작성한다.</li>
                <li><span>4~8</span>블록 외부에서 접근할 경우 에러 발생.</li>
            </ol>
        </div>
        
        <script type="syntaxhighlighter" class="brush: js;">
        <![CDATA[
            const MY_FAV = 7;       // 상수 MY_FAV를 정의하고 7을 할당
            MY_FAV = 20;            // 에러(재할당)
            console.log("my favorite number is: " + MY_FAV);    // 7

            const MY_FAV = 20;      // 에러(재선언)
            var MY_FAV = 20;        // 에러(이미 상수로 예약됨)
            let MY_FAV = 20;        // 에러(이미 상수로 예약됨)

            if (MY_FAV === 7) { 
                let MY_FAV = 20;    // let 키워드로 선언한 변수는 같은 이름이어도 블록 범위로 지정되어 문제없다.
                console.log('my favorite number is ' + MY_FAV);     // 20
                var MY_FAV = 20;    // 전역으로 호이스트되어 에러 발생(Uncaught SyntaxError: Identifier 'MY_FAV' has already been declared)
            }
            console.log('my favorite number is ' + MY_FAV);     // 7
            
            const FOO;              // const 선언시에 초기값을 생략 오류
            const MY_OBJECT = {'key': 'value'};     // const는 오브젝트에도 잘 동작한다.
            MY_OBJECT = {'OTHER_KEY': 'value'};     // 오브젝트를 덮어쓰면 오류 발생
            MY_OBJECT.key = 'otherValue';   // 오브젝트의 키는 보호되지 않아서 문제없이 실행된다. 오브젝트를 변경할 수 없게 하려면 Object.freeze() 를 사용해야 한다.
            
            const MY_ARRAY = [];            // 배열에도 똑같이 적용된다.
            MY_ARRAY.push('A');             // ["A"] 배열에 아이템을 삽입은 가능
            MY_ARRAY = ['B']                // 변수에 새로운 배열을 배정하면 에러 발생
        ]]>
        </script>
        
        <div class="content">
            <ul class="bull_list">
                <li>const 키워드로 정의된 상수에 객체를 할당하면 불변 객체(정의된 후에 그 상태를 바꿀 수 없는 객체)가 되지는 않는다.</li>
            </ul>
        </div>
        <script type="syntaxhighlighter" class="brush: js;">
        <![CDATA[
            const CONST_USER = { name: 'jay', age: 30 };
            console.log(CONST_USER.name, CONST_USER.age);       // jay 30
            CONST_USER.name = "jay2";
            CONST_USER.age = 31;
            console.log(CONST_USER.name, CONST_USER.age);       // jay2 31
            CONST_USER = { name: 'bbo' };                       // Uncaught TypeError: Assignment to constant variable.            
        ]]>
        </script>
        <div class="desc">
            <ol>
                <li><span>1~5</span>const로 정의된 상수에 할당된 객체는 불변 객체가 아니어서 객체의 속성을 추가 하거나 변경할 수 있다.</li>
                <li><span>6</span>재할당 할수 없어서 새로운 객체로 할당 못하고 객체 내부의 상태만 변경할 수 있다.</li>
            </ol>
        </div>
    </div>
    
    <div>
        <h2><span>초급 043</span>스코프 체인 이해하기</h2>
        <div class="content">
            <ul class="bull_list">
                <li>스코프 체인(스코프가 연결되어 있음)을 이해하기 위해 먼저 실행 컨텍스트, 렉시컬 환경을 알아야 한다.</li>
                <li><p>실행 컨텍스트(Execution Context)</p>코드 실행을 위한 정보를 가지고 있으며 코드가 실행될 때 생성된다. 대표적 실행 가능한 코드는 전역 코드와 함수 코드가 있고 그 외 eval, 모듈 코드가 있다.<br>
                    전역 코드가 먼저 실행되며 이때 전역 컨텍스트를 만들고 전역 코드를 순차적으로 평가한다. 평가중 함수가 호출문을 만나면 새로운 실행 컨텍스트가 만들어지면서 해당 함수의 코드를 순차적으로 평가한다. 이때 새로운 실행 컨텍스트가 생성되면 스택(Stack)에 쌓고 실행 중인 코드가 종료되면 해당 실행 컨텍스트를 스택에서 제거한다.
                </li>
            </ul>
            <script type="syntaxhighlighter" class="brush: js;">
            <![CDATA[
                var person = 'harin';

                function print() {
                  var person2 = 'jay';

                    function innerPrint() {
                    console.log(person);    // harin
                    console.log(person2);   // jay
                  }

                    innerPrint();

                    console.log('print finished');  // print finished
                }

                print();
                console.log('finished');    // finished          
            ]]>
            </script>
            
            <p>실행 컨텍스트가 실행될 때 시간에 따라 스택에 쌓이고 제거되는 과정</p>
            <div class="ex43">
                <ul>
                    <li><div><ul><li>전역 실행<br>컨텍스트</li></ul><p>16문장 전까지</p></div></li>
                    <li><div><ul><li>전역 실행<br>컨텍스트</li><li>print 실행<br>컨텍스트</li></ul><p>16문장에서 print<br>실행 컨텍스트 생성</p></div></li>
                    <li><div><ul><li>전역 실행<br>컨텍스트</li><li>print 실행<br>컨텍스트</li><li>innerPrint<br>실행 컨텍스트</li></ul><p>4문장 ~ 11까지<br>실행 후 innerPrint<br>실행 컨텍스트 생성</p></div></li>
                    <li><div><ul><li>전역 실행<br>컨텍스트</li><li>print 실행<br>컨텍스트</li></ul><p>13문장 실행</p></div></li>
                    <li><div><ul><li>전역 실행<br>컨텍스트</li></ul><p>17문장</p></div></li>
                </ul>
            </div>
            <ul class="bull_list">
                <li><p>렉시컬 환경(Lexical Environment)</p>실행 컨텍스트는 렉시컬 환경을 가지고 있는데, 렉시컬 환경은 환경 레코드(EnvironmentRecord)와 외부 렉시컬 환경(OuterLexicalEnvironment)으로 구성된다. 실행 컨텍스트를 자바스크립트 객체 형태로 표현하면 다음과 같다.</li>
            </ul>
            <script type="syntaxhighlighter" class="brush: js;">
            <![CDATA[
                ExcutionContext = {
                    LexicalEnvironnment : {
                        EnvironmentRecord : {
                            
                        },
                        OuterLexicalEnvironment : 참조
                    }
                }
            ]]>
            </script>
            <ul class="bull_list">
                <li>실제 함수와 변수 같은 식별자와 그 식별자가 가리키는 값은 키(key)와 값의 쌍으로 환경 레코드(EnvironmentRecord)에 기록된다. 렉시컬 환경은 환경 레코드 외에 자신의 실행 환경을 감싸는 외부 실행 환경에 대한 참조를 가지고 있다.<br>
                위 코드의 실행 컨텍스트와 내부 렉시컬 환경을 그림으로 나타내면 다음과 같다.</li>
            </ul>
            <div class="ex43_02">
                <ul>
                    <li><strong>전역 실행 컨텍스트</strong>
                        <pre>
LexicalEnvironment:{
    environmentRecoard: {
        person: 'harin',
        print: &lt;function&gt;
    },
    outerLexicalEnvironment: <span>null</span>
}                        </pre>
                    </li>
                    <li><strong>print 실행 컨텍스트</strong>
                        <pre>
LexicalEnvironment:{
    environmentRecoard: {
        person: 'jay',
        print: &lt;function&gt;
    },
    outerLexicalEnvironment: 
}                        </pre>
                    </li>
                    <li><strong>inner 실행 컨텍스트</strong>
                        <pre>
LexicalEnvironment:{
    environmentRecoard: {
    
        
    },
    outerLexicalEnvironment: 
}                        </pre>
                    </li>
                </ul>
            </div>
            <ul class="bull_list">
                <li>각 실행 컨텍스트는 outerLexicalEnvironment로 체인처럼 연결되어 있기 때문에 스코프 체인이 형성될 수 있다.</li>
            </ul>
        </div>
        <script type="syntaxhighlighter" class="brush: js;">
            <![CDATA[
                var person = 'harin';

                function print() {
                  var person2 = 'jay';

                    function innerPrint() {
                    console.log(person);    // harin
                    console.log(person2);   // jay
                  }

                    innerPrint();

                    console.log('print finished');  // print finished
                }

                print();
                console.log('finished');    // finished          
            ]]>
        </script>
        <div class="desc">
            <ol>
                <li><span>7~8</span>11라인의 innerPrint 함수가 호출될 때 두 변수 person과 person2 즉 각 식별자는 연결된 값을 자신의 실행 컨텍스트의 렉시컬 환경에서 찾지만 함수 내에 선언되지 않아 inner 실행 컨텍스트의 환경 레코드에는 아무런 키-값의 쌍이 없게 된다.<br>
                자신의 실행 컨텍스트에 없으면 외부 렉시컬 환경의 참조를 통해 연결된 print 실행 컨텍스트에서 해당 식별자를 찾게 된다.<br>
                이 때 person2는 print 실행 컨텍스트의 환경 레코드에서 찾아 'jay'를 출력하고 person은 전역 실행 컨텍스트까지 가서 값을 찾아 'harin'을 출력한다.</li>
            </ol>
        </div>	
    </div>
    
    <div>
        <h2><span>초급 044</span>클로저 이해하기</h2>
        <div class="content">
            <ul class="bull_list">
                <li><p>클로저</p>함수가 정의될 때의 렉시컬 환경을 기억하는 함수</li>
            </ul>
        </div>
        <script type="syntaxhighlighter" class="brush: js;">
        <![CDATA[
            function createCounterClosure() {
                let count = 0;
                return {
                    increase: function() {
                        count++;
                    },
                    getCount: function() {
                      return count;
                    }
                }
            }

            const counter1 = createCounterClosure();
            const counter2 = createCounterClosure();

            counter1.increase();
            counter1.increase();
            console.log('counter 1의 값 : ' + counter1.getCount());   // counter 1의 값 : 2
            counter2.increase();
            console.log('counter 2의 값 : ' + counter2.getCount());   // counter 2의 값 : 1         
        ]]>
        </script>
        <div class="desc">
            <ol>
                <li><span>1~2</span>createCounterClosure 함수를 정의, count 변수에 0 할당.</li>
                <li><span>3~11</span>createCounterClosure 함수는 객체를 반환하는데 객체에는 increase, getCount 메소드가 있고, 모두 count 변수에 접근한다.</li>
                <li><span>13~14</span>createCounterClosure 함수를 호출하고 반환된 객체를 counter1과 counter2에 할당한다.</li>
                <li><span>16~20</span>counter1, counter2 모두 객체의 increase 메소드를 호출해서 createCounterClosure 함수 내부의 count 변수에 접근하지만 getCount를 호출한 결과를 보면 counter1의 메소드들이 가리키는 count와 counter2의 메소드들이 가리키는 count가 다른 값을 가지고 있음을 알 수 있다.</li>
            </ol>
        </div>	
        <div class="content">
            <ul class="bull_list">
                <li>4라인, 7라인의 increase와 getCount 함수가 정의될 때의 렉시컬 환경은 createCounterClosure 실행 컨텍스트의 렉시컬 환경이다. 이 실행 컨텍스트는 13,14라인에서 각각 생성되며 increase 함수와 getCount 함수는 createCounterClosure 실행 컨텍스트의 렉시컬 환경을 기억하고 있는 클로저가 된다.</li>
                <li>실행 컨텍스트가 컨텍스트 스택에서 제거되면 해당 환경은 사라지지만 클로저가 만들어지면 해당 참조가 존재하기 때문에 사라지지 않는다. 예제의 counter1, counter2는 전역 변수에 할당되어 참조가 존재한다. </li>
            </ul>
        </div>
    </div>
	
	<h1>javascript 200제</h1>
    <div>
        <h2><span>초급 045</span>객체 속성 기술자 이해하기</h2>
        <div class="content">
            <ul class="bull_list">
                <li><p></p></li>
            </ul>
        </div>
        <script type="syntaxhighlighter" class="brush: js;">
        <![CDATA[
            let user = {
              name: "jeado"
            };
            let descriptor = Object.getOwnPropertyDescriptor(user, 'name');
            console.log(descriptor);        // {value: "jeado", writable: true, enumerable: true, configurable: true}

            let user2 = {};
            Object.defineProperty(user2, "name", {
              value: "jeado",
              enumerable: true,
              configurable: true,
              writable: false
            });
            console.log(user2.name);        // jeado
            user2.name = "bbo";
            console.log(user2.name);        // jeado

            let user3 = {
              name: "jeado",
              toString() {
                return this.name;
              }
            };
            Object.defineProperty(user3, "toString", {
              enumerable: false
            });
            for (let key in user3) {
              console.log(key);             // name
            }

            let user4 = {};
            Object.defineProperty(user4, "name", {
              value: "jeado",
              configurable: false
            });
            delete user4.name
            console.log(user4);             // {name: "jeado"}
            Object.defineProperty(user4, "name", {      // Uncaught TypeError: Cannot redefine property: name at Function.defineProperty (<anonymous>)
              writable: true
            });            
        ]]>
        </script>
        <div class="desc">
            <ol>
                <li><span>1~5</span>자바스크립트의 객체는 자신의 정보를 담고 있는 속성 기술자(Property Descriptor)를 가지고 있다. 속성 기술자는 객체로 표현되어 4라인처럼 Object.getOwnPropertyDescriptor로 속성 기술자 객체를 가져올 수 있다.</li>
                <li><span>7~16</span>객체 user2를 선언하고 Object.defineProperty로 해당 객체의 속성을 정의한다. 첫 번째 인자는 속성을 정의할 객체, 두 번째 인자는 속성명, 세 번째 인자는 속성 기술자이다.</li>
                <li><span></span>
                    <div>
                        <ul class="bull_list">
                            <li><p>value</p>값</li>
                            <li><p>enumerable</p>for ~ in 루프, Object.keys 메소드 같이 속성을 나열할 때 나열 가능 여부</li>
                            <li><p>writable</p>값을 변경할 수 있는 여부.</li>
                            <li><p>configurable</p>속성 기술자를 변경할 수 있는 여부.</li>
                        </ul>
                        <p style="margin-top:5px;">15라인에서 값을 재할당 하지만 writable : false이기 때문에 값이 변경 되지 않고 기존 값을 출력한다.</p>
                    </div>
                </li>
                <li><span>18~29</span>user3 객체를 선언하고 for ~ in 루프로 모든 속성 키(name, toString)를 출력해야 되지만 24~26라인의 enumerable 속성값이 false여서 toString은 출력되지 않는다.</li>
                <li><span>31~40</span>user4 객체에 configurable 속성값을 false로 선언(속성 기술자를 변경할 수 없음)해서 name 속성을 삭제하지 못하고 false를 리턴한다. name 속성값을 출력하면 변동 없이 "jeado"이다. 38~40라인에서 속성기술자 값을 변경하려고 하지만 이미 configurable : false로 속성 기술자를 변경할수 없어 에러가 발생한다.</li>
            </ol>
        </div>	
    </div>
        
    <div>
        <h2><span>초급 046</span>Get, Set을 통한 속성 접근 관리하기</h2>
        <script type="syntaxhighlighter" class="brush: js;">
        <![CDATA[
            let user = {};
            Object.defineProperty(user, "age", {
              get: function () {
                return this._age;
              },
              set: function (age) {
                if (age < 0) {
                  console.error('0보다 작은값은 올 수 없습니다.');
                } else {
                  this._age = age;
                }
              },
              enumerable: true
            });
            user.age = 10;
            console.log(user.age);
            user.age = -1;

            let user2 = {
              get name() {
                return this._name;    
              },
              set name(val) {
                if (val.length < 3) {
                  throw new Error('3자 이상이어야 합니다.');
                }
                this._name = val;    
              }
            }
            user2.name = 'harin';
            console.log(user2.name);
            user2.name = 'ha';
            
            결과 :  10
                    VM53:8 0보다 작은값은 올 수 없습니다.
                    harin
                    3자 이상이어야 합니다.
        ]]>
        </script>
        <div class="desc">
            <ol>
                <li><span>1~14</span>속성기술자로 객체 user의 age 속성을 정의한다. 이때 값에 접근하는 방석을 정의하는 객체(접근 기술자 : Accessor Descriptor)를 전달하는데 get, set 메소드를 가지고 있다.<br>
                    get 메소드 : 속성에 접근할 때 호출<br>
                    set 메소드 : 속성에 값을 대입할 때 호출</li>
                <li><span>3~5</span>get 메소드는 속성에 접근할 때 호출된다. user.age에 접근하면 user._age의 결과를 반환한다.</li>
                <li><span>6~11</span>set 메소드는 속성에 값을 대입할 때 호출된다. 할당하는 값이 0보다 작으면 에러 로그를 출력, 0보다 크면 _age 속성에 값을 대입</li>
                <li><span>15~16</span>user.age에 10을 대입한다. age 속성 접근 기술자의 set 메소드가 호출되고, user 객체의 _age 속성값 10을 출력한다.</li>
                <li><span>17</span>user.age에 -1을 대입한다. 접근 기술자의 set 메소드가 호출되면서 0보다 작은 조건에 의해 에러 로그를 출력한다.</li>
                <li><span>19~29</span>user2 객체를 정의할 때 name 속성의 접근 기술자를 정의한다. 객체를 정의할 때 메소드를 정의하는 메소드명 앞에 get, set으로 각각의 메소드를 정의할 수 있다.</li>
                <li><span>30~32</span>user2 객체의 name 속성에 값을 할당할 때 접근 기술자의 set 메소드가 호출된다. 조건에 맞지 않으면 콘솔에 에러 메시지를 출력한다.</li>
            </ol>
        </div>
        <div class="content">
            <ul class="bull_list">
                <li>예제에서 속성 이름에 _는 암묵적인 비공개(Private) 속성을 의미하며 자바스크립트 객체는 속성 제한자가 없어서 모든 속성은 공개(Public)이다. 그래서 대체로 이름 규칙을 통해 비공개임을 나타낸다.</li>
            </ul>
        </div>
    </div>
    
    <div>
        <h2><span>초급 047</span>화살표 함수 이해하기</h2>
        <div class="content">
            <p>ES6에서 함수를 간결하게 표현하면서 기능이 개선된 화살표 함수가 추가 되었다. 화살표 함수는 function 키워드를 사용하지 않고 =&gt; 연산자를 이용하여 정의하며 몇가지 규칙이 있다.</p>
            <ul class="bull_list">
                <li>매개변수가 하나일 경우 인자를 정의할 때 괄호 생략가능</li>
                <li>매개변수가 없거나 둘 이상일 경우 괄호 작성 필수</li>
                <li>화살표 함수 코드 블록을 지정없이 한 문장으로 작성 시 return문이 없어도 화살표 오른쪽 표현식의 계산 결과값이 반환된다.</li>
                <li>화살표 함수 코드 블록을 지정했다면 반환을 원하는 값에 return문을 작성해야 한다. return문이 없다면 undefined를 반환</li>
            </ul>
        </div>
        <script type="syntaxhighlighter" class="brush: js;">
        <![CDATA[
            const double = x => x + x;
            console.log(double(2));     // 4

            const add = (a, b) => a + b;
            console.log(add(1, 2));     // 3

            const printArguments = () => {
              console.log(arguments);
            }
            printArguments(1, 2, 3);   // arguments is not defined : 화살표 함수에 코드 블록에는 return문을 작성해야하나 없어서 에러

            const sum = (...args) => {
              let total = 0;
              for (let i = 0; i < args.length; i++) {
                total += args[i];
              }
              return total;
            }
            console.log(sum(1, 2, 3));  // 6

            setTimeout(() => {
              console.log('화살표 함수!');   // 화살표 함수!
            }, 10);
        ]]>
        </script>
        <div class="desc">
            <ol>
                <li><span>1~2</span>매개변수가 하나여서 괄호 생략, 코드 블록 지정없이 한 문장으로 작성해서 return문 없어도 결과값을 반환한 케이스<br>매개변수 x를 받아 x + x의 결과를 반환하는 화살표 함수를 선언하고 변수 double 할당한다. double(2)는 2 + 2의 값인 4를 출력한다.</li>
                <li><span>4~5</span>매개변수가 둘 이상이어서 괄호를 필수로 작성, 코드 블록 지정없이 한 문장으로 작성해서 return문 없어도 결과값을 반환한 케이스</li>
                <li><span>7~10</span>매개변수를 정의하지 않아서 빈 괄호로 표현했다. 화살표 함수 코드 블록 내부는 콘솔로 arguments를 출력하지만 return문이 없기 때문에 반환값이 없다. 10라인에서 인자로 1,2,3을 전달하면서 화살표 함수를 호출하지만 화살표 함수는 기본 함수와 다르게 arguments 객체가 만들어지지 않아 에러가 발생한다.</li>
                <li><span>12~19</span>인자의 합을 구하는 화살표 함수를 정의했다. arguments객체 대신 나머지 연산자로 매개변수를 정의했기 때문에 전달받은 인자 목록을 배열로 사용할 수 있다. 화살표 함수 코드 블록에 대괄호를 사용했기 때문에 return문은 작성해서 반환값을 명시한다.</li>
                <li><span>21~23</span>화살표 함수 또한 함수의 인자로 전달 가능하다. 매개변수가 없어서 빈괄호를 작성했다.</li>
            </ol>
        </div>	
    </div>
    
    <div>
        <h2><span>초급 048</span>자바스크립트 객체지향 프로그래밍 이해하기</h2>
        <div class="content">
            <ul class="bull_list">
                <li><p>객체지향 프로그래밍</p>프로그램을 객체들로 구성하고 객체들 간에 서로 상호작용하도록 작성하는 방법이다. 예제 28번 객체 이해하기에서 객체는 값을 그룹으로 묶은 데이터 모음이라고 정의했지만 객체지향에서 객체란 식별 가능한 구체적인 사물 또는 추상적인 개념이라고 정의한다.</li>
                <li>객체는 특징적인 행동과 변경 가능한 상태를 가지며 자바스크립트에서는 함수 값으로 가지는 속성을 메소드라고 하는데 이 메소드가 특징적인 행동이며, 그 외에 다른 값들은 변경 가능한 상태라 볼수 있다.</li>
                <li>자바스크립트의 객체를 객체지향에서 말하는 객체로 사용하려면 그에 맞게 코드를 작성해야 하며 객체를 정의한것만으로는 객체지향 프로그래밍을 하는 것은 아니다.</li>
            </ul>
        </div>
        <script type="syntaxhighlighter" class="brush: js;">
        <![CDATA[
            const teacherJay = {
                name: '제이',
                age: 40,
                teachJavascript: function(student) {
                    student.gainExp();
                }
            }

            const studentBbo = {
                name: "뽀",
                age: 20,
                exp: 0,
                gainExp: function() {
                    this.exp++;
                }
            };
            console.log(studentBbo.exp);        // 0
            teacherJay.teachJavascript(studentBbo);
            console.log(studentBbo.exp);        // 1
        ]]>
        </script>
        <div class="desc">
            <ol>
                <li><span>1~7</span>객체 teacherJay의 teachJavascript 메소드는 student를 매개변수로 정의하고 있어서 student 객체를 사용한다. 객체지향에서는 메소드를 통해 서로 메시지를 전달한다. 객체지향에서는 협력하지 않는 객체란 없으며 협력은 메시지 전달을 통해 이루어 진다.</li>
                <li><span>9~16</span>객체 studentBbo는 gainExp로 내부 상태인 경험치를 변경시킬수 있다.</li>
            </ol>
        </div>
        
        <div class="content">
            <ul class="bull_list">
                <li><p>분류</p>객체의 공통적인 특성을 기준으로 객체를 묶어 하나의 타입으로 정의하는 작업으로 일종의 추상화를 하는 것이다.<br>세상에는 많은 자바스크립트를 가르치는 선생이 있고 그중의 teacherJay도 일부 객체이다. 여기서 자바스크립트 선생이란 타입을 분류하고 자바스크립트를 가르치는 공통 특징이 있다고 정의할 수 있다.</li>
                <li>자바스크립트는 프로토타입 기반으로 객체지향 프로그래밍을 지원한다. 자바의 클래스 기반과 달리 프로토타입으로 객체에 공통 사항을 적용할 수 있어서 모든 객체는 다른 객체의 원형(Prototype)이 될수 있다. 특징을 묘사하는 원형 객체를 만들고 이 객체에 기반하는 객체를 만들면 모두 같은 특징을 가질수 있다.</li>
            </ul>
        </div>
        <script type="syntaxhighlighter" class="brush: js;">
        <![CDATA[
            const studentProto = {
                gainExp: function() {
                    this.exp++;
                }
            };

            const harin = {
                name: '하린',
                age: 10,
                exp: 0,
                __proto__: studentProto
            };

            const bbo = {
                name: "뽀",
                age: 20,
                exp: 10,
                __proto__: studentProto
            };

            bbo.gainExp();
            harin.gainExp();
            harin.gainExp();

            console.log(harin);     // {name: "하린", age: 10, exp: 2}
            console.log(bbo);       // {name: "뽀", age: 20, exp: 11}
        ]]>
        </script>
        <div class="desc">
            <ol>
                <li><span>1~5</span>gainExp메소드를 가진 원형(prototype) 객체 studentProto를 정의</li>
                <li><span>7~12</span>자바스크립트에서는 원형 객체를 __proto__ 속성으로 정의하며 다른 객체를 선언하지 않으면 기본적으로 Object.prototype 객체가 연결된다. 객체 harin은 __proto__ 속성에 객체 studentProto를 연결했기 때문에 gainExp메소드를 실행할 수 있다.</li>
                <li><span>14~19</span>객체 bbo는 객체 harin과 속성 값은 다르지만 __proto__ 속성에 객체 studentProto를 연결했기 때문에 객체 harin과 같이 gainExp메소드를 실행할 수 있다.</li>
                <li><span>21~23</span>객체 harin, bbo 둘다 같은 원형 객체에 연결되어 있어서 gainExp메소드를 실행할 수 있고 두 객체는 학생 타입이라 할 수 있다.</li>
            </ol>
        </div>	
    </div>
    
    <div>
        <h2><span>초급 049</span>생성자 함수 이해하기</h2>
        <div class="content">
            <ul class="bull_list">
                <li>자바스크립트 함수는 재사용 가능한 코드의 묶음으로 사용하는 것 외에 객체를 생성하기 위한 방법으로도 사용된다. 객체를 생성하기 위해 직접적으로 객체를 반환해도 되지만, new 키워드를 사용하여 함수를 호출하면 return문 없이 새로운 객체가 반환되며 함수 바디에서 this 키워드로 반환되는 초기 상태와 행위를 정의할 수 있다.</li>
                <li>이렇게 객체를 생성하는 역할을 하는 함수를 생성자 함수라고 하는데 new 키워드를 사용하지 않으면 일반적인 함수와 동일하게 작동하며 새로운 객체를 반환하지 않기 때문에 함수명을 대문자로 시작하는게 관례이다.</li>
                <li>객체에 타입이 적용되면 해당 객체는 그 타입의 인스턴스라고 부른다. 앞의 예제의 두 객체 모두 학생 타입의 인스턴스라 할 수 있다. 생성자 함수는 새로운 타입을 정의하는데 사용되어서 new 키워드로 만들어진 객체는 해당 타입의 인스턴스가 된다.</li>
            </ul>
        </div>
        <script type="syntaxhighlighter" class="brush: js;">
        <![CDATA[
            function Teacher(name, age, subject) {
                this.name = name;
                this.age = age;
                this.subject = subject;
                this.teach = function (student) {
                    console.log(student + '에게 ' + this.subject + '를 가르칩니다.');       // bbo에게 JavaScript를 가르칩니다.
                };
            }

            const jay = new Teacher('jay', 30, 'JavaScript');
            console.log(jay);                       // Teacher {name: "jay", age: 30, subject: "JavaScript", teach: ƒ}
            jay.teach('bbo');

            console.log(jay.constructor);           // Teacher(name, age, subject) {...}
            console.log(jay instanceof Teacher);    // true

            const jay2 = Teacher('jay', 30, 'JavaScript');
            console.log(jay2);                      // undefined
            console.log(age);                       // 30
        ]]>
        </script>
        <div class="desc">
            <ol>
                <li><span>1~8</span>생성자 함수 Teacher를 정의한다. 전달 받은 매개변수의 값을 this의 속성으로 대입하고 teach 메소드를 정의한다.</li>
                <li><span>10</span>new 키워드로 생성자 함수를 호출하면 생성자 함수 블록이 실행되고 별도의 return문 없이 새로운 객체가 반환된다. 이때 반환되는 새로운 객체를 가리키는 것이 this이다. 그래서 변수 jay에 반환된 객체가 할당된다.</li>
                <li><span>11~12</span>Teacher 타입의 객체를 콘솔에 출력하고 해당 객체의 teach 메소드를 호출해서 'bbo에게 JavaScript를 가르칩니다.'를 출력</li>
                <li><span>14~15</span>모든 객체는 constructor 속성을 가지고 있으며 객체를 만든 생성자 함수를 가리키고 콘솔로 해당 내용을 출력한다. instanceof 연산자를 이용하면 객체 jay가 Teacher 생성자 함수의 인스턴스 여부를 확인할 수 있다.</li>
                <li><span>17~19</span>new 키워드 없이 Teacher 생성자 함수를 호출한다. 이때 생성자 함수의 this는 전역 객체를 가리키며 전역 객체에 전달 받은 매개변수가 할당 된다. 그래서 전역 변수의 age를 참조해 콘솔에 30이 출력되고 새로운 객체가 반환되지 않은 jay2는 undefined가 출력된다.</li>
            </ol>
        </div>	
        
        <div class="content">
            <p>생성자 함수의 new 호출을 통한 객체 생성 과정</p>
            <ul class="bull_list interval01">
                <li>빈 객체를 생성</li>
                <li>생성한 빈 객체를 this에 할당</li>
                <li>생성자 함수 바디의 코드를 실행한다.(this에 속성 및 메소드 추가)</li>
                <li>생성한 빈 객체의 __proto__에 생성자 함수의 prototype 속성을 대입한다.</li>
                <li>this를 생성자의 반환값으로 변환한다.</li>
            </ul>
        </div>
    </div>
    
    <div>
        <h2><span>초급 050</span>프로토타입 기반 상속 이해하기</h2>
        <div class="content">
            <ul class="bull_list">
                <li>자바스크립트에서 생성자 함수로부터 만들어진 객체는 프로토타입 객체를 상속하므로 모든 인스턴스는 해당 생성자 함수의 프로토타입 객체의 속성, 메소드를 사용할 수 있다.</li>
                <li>자바스크립트에서 모든 함수는 prototype 속성으로 프로토타입 객체를 가지며 모든 객체는 __proto__ 속성을 가지는데 이 속성은 해당 객체를 생성한 생성자 함수의 prototype 객체를 가리킨다. 그래서 생성자 함수를 통해서 타입을 정의할 수 있다.</li>
            </ul>
        </div>
        <script type="syntaxhighlighter" class="brush: js;">
        <![CDATA[
            function Storage() {
                this.dataStore = {};
            }
            Storage.prototype.put = function(key, data) {
                this.dataStore[key] = data;
            }
            Storage.prototype.getData = function(key) {
                return this.dataStore[key];
            }

            const productStorage = new Storage();
            productStorage.put('id001', { name: '키보드', price: 2000 });
            console.log(productStorage.getData('id001'));       // {name: "키보드", price: 2000}

            function RemovableStorage() {
                Storage.call(this);
            }
            RemovableStorage.prototype = Object.create(Storage.prototype);
            RemovableStorage.prototype.removeAll = function() {
                this.dataStore = {}
            }
            const productStorage2 = new RemovableStorage();
            productStorage2.put('id001', { name: '키보드', price: 2000 });
            productStorage2.removeAll();
            const item2 = productStorage2.getData('id001');
            console.log(item2);                     // undefined
        ]]>
        </script>
        <div class="desc">
            <ol>
                <li><span>1~3</span>내부 속성으로 빈 객체 dataStore를 가진 생성자 함수 Storage를 정의한다.</li>
                <li><span>4~6</span>생성자 함수 Storage의 프로토타입 객체에 주어진 키에 해당하는 값을 dataStore 속성에 할당하는 put 메소드를 추가한다.</li>
                <li><span>7~9</span>생성자 함수 Storage의 프로토타입 객체에 매개변수의 값을 키로 해서 dataStore 속성에 할당하는 getData 메소드를 추가한다.</li>
                <li><span>11~12</span>Storage의 인스턴스를 생성하면 인스턴스는 해당 생성자 함수의 프로토타입을 상속받아 프로토타입의 메소드를 사용할 수 있다.</li>
                <li><span>15~17</span>생성자 함수 RemovableStorage를 정의한다. 이때 Storage 함수를 호출하면서 this를 전달하게 되는데 이렇게 되면 Storage 생성자 함수가 호출되면서 RemovableStorage 생성자 함수의 this에 Storage 생성자 함수에서 정의한 dataStore가 속성으로 추가 된다.</li>
                <li><span>18~21</span>Object.create 메소드는 주어진 인자를 __proto__에 연결한 새로운 객체를 반환한다. Object.create를 이용하면 간단하게 상속 관계를 형성할 수 있다. RemovableStorage.prototype에 Object.create(Storage.prototype)를 할당하면 Storage 함수의 프로토타입 객체가 RemovableStorage 함수의 프로토타입 객체의 __proto__에 할당되면서 두 프로토타입이 상속 관계를 형성하게 된다. 그리고 RemovableStorage 생성자 함수의 프로토타입 객체에 removeAll 메소드를 추가한다.</li>
                <li><span>22~26</span>생성자 함수 RemovableStorage에 의해 만들어 지는 인스턴스들은 내부에 없는 메소드가 있다면 생성자 함수 RemovableStorage, Storage의 프로토타입에서 순차적으로 찾아서 Object.prototype에서까지 찾게 된다. 이렇게 프로토타입 객체가 서로 연결되어 있어서 프로토타입 체인이라고 한다.<br>
                예제에서는 put, removeAll, getData 메소드는 생성자 함수 RemovableStorage의 인스턴스에 없지만 상속을 받은 프로토타입에서 순차적으로 찾아서 사용할수 있게 된다. 
                </li>
            </ol>
        </div>	
    </div>
    
    <div>
        <h2><span>초급 051</span>클래스 정의하기</h2>
        <div class="content">
            <ul class="bull_list">
                <li>ES6부터 class 키워드로 클래스를 정의할 수 있다.</li>
                <li><p>클래스</p>별도 타입의 객체를 생성하는 설계 도면이라 볼 수 있다. 클래스를 통해 객체가 가져야 할 상태, 행위를 속성과 메소드로 정의할 수 있다. 클래스로 정의하면 해당 클래스에서 생성된 객체는 동일한 행위를 할 수 있다. 특정 클래스를 통해 만들어진 객체를 해당 클래스의 인스턴스라고 한다.</li>
            </ul>
        </div>
        <script type="syntaxhighlighter" class="brush: js;">
        <![CDATA[
            class Cart {
                constructor() {
                    this.store = {};
                }

                addProduct(product) {
                    this.store[product.id] = product;
                }

                getProduct(id) {
                    return this.store[id];
                }
            }

            const cart1 = new Cart();

            cart1.addProduct({ id: 1, name: '노트북'})
            console.log(cart1.store);           // {1: {…}}

            const p = cart1.getProduct(1);
            console.log(p);                     // {id: 1, name: "노트북"}
        ]]>
        </script>
        <div class="desc">
            <ol>
                <li><span>1</span>클래스 Cart를 정의한다.(관례상 첫 글자는 대문자) 클래스명 이후 중괄호가 오고 내부를 클래스 몸통이라 부른다</li>
                <li><span>2~4</span>클래스 몸통에는 생성자 함수를 작성할 수 있다. ES6 이전 생성자 함수와 같은 역할 이지만 function 키워드가 없고 함수 이름이 constructor로 고정, 매개변수를 정의 할수 있고 하나의 생성자만 정의할 수 있다. 생성자는 new 키워드를 통해 객체가 생성될 때 호출된다. 예제에서는 store 속성에 빈 객체를 추가한다. 생성자 함수에서는 매개변수에서 전달받은 값을 속성으로 추가하거나 속성의 초기값을 대입하는 초기화 과정을 주로 한다.</li>
                <li><span>6~12</span>addProduct, getProduct 메소드를 정의한다. 메소드는 클래스가 생성한 객체를 통해 사용 가능하다. 17라인에서 cart1 인스턴스를 통해 addProduct를 호출하고 있다. store 객체의 키에 전달받은 product 객체의 id를 저장한다. getProduct 메소드를 통해 전달받은 id인자에 해당하는 product를 반환한다.</li>
                <li><span>15</span>변수 cart1에 new 키워드로 생성한 클래스 Cart의 인스턴스를 할당한다. (변수 cart1는 const로 정의해서 다른 값을 대입할 수 없다.)</li>
                <li><span>17~19</span>cart1 인스턴스의 addProduct 메소드에 객체를 전달하여 호출한다. 6~7 라인에 정의한대로 store 속성에 매개변수의 id의값 1이 객체의 값으로 추가된다.</li>
                <li><span>20~21</span>getProduct 메소드로 id 1에 해당하는 상품 객체를 반환받아 콘솔에 출력한다.</li>
            </ol>
        </div>	
    </div>
    
    <div>
        <h2><span>초급 052</span>클래스 상속 이해하기</h2>
        <script type="syntaxhighlighter" class="brush: js;">
        <![CDATA[
            class Chart {
                constructor(width, height) {
                    this.width = width;
                    this.height = height;
                }

                drawLine() {
                    console.log("draw line");       // draw line
                }
            }

            class BarChart extends Chart {
                constructor(width, height) {
                    super(width, height);
                }

                draw() {
                    this.drawLine();
                    console.log(`draw ${this.width} X ${this.height} barChart`);        // draw 100 X 100 barChart
                }
            }

            const barchart1 = new BarChart(100, 100);
            barchart1.draw();            
        ]]>
        </script>
        <div class="desc">
            <ol>
                <li><span>1~10</span>Chart 클래스를 정의한다. drawLine 메소드로 라인을 그리게 된다.</li>
                <li><span>12~15</span>Chart 클래스를 상속하는 BarChart 클래스를 정의한다. extends 키워드로 클래스를 상속할 수 있고 super 키워드는 생성자 함수에서 상속한 부모 클래스의 생성자를 호출할 때 사용한다. super가 부모 생성자 함수를 기리킨다.</li>
                <li><span>17~20</span>상속을 해서 부모 클래스에 정의된 메소드를 사용할 수 있다.</li>
                <li><span>23~24</span>변수 BarChart1에 BarChart 클래스의 인스턴스를 할당하고 draw 메소드를 호출한다. 부모 클래스인 Chart의 생성자 함수가 호출되어 width, height 속성에 주어진 값이 할당되고 부모 클래스의 drawLine 메소드가 호촐된다.</li>
            </ol>
        </div>	
    </div>
    
    <div>
        <h2><span>초급 053</span>클래스 정적 메소드와 속성 정의하기</h2>
        <div class="content">
            <ul class="bull_list">
                <li><p>일반적인 메소드</p>해당 클래스의 인스턴스를 통해 호출</li>
                <li><p>정적 메소드</p>클래스를 통해 직접 호출한다. static 키워드로 정의해서 사용한다.</li>
            </ul>
        </div>
        <script type="syntaxhighlighter" class="brush: js;">
        <![CDATA[
            class Product {
                static build(name, price) {
                    const id = Math.floor(Math.random() * 1000);
                    return new Product(id, name, price);
                }

                static getTaxPrice(product) {
                    return (product.price * 0.1) + product.price;
                }

                constructor(id, name, price) {
                    this.id = id;
                    this.name = name;
                    this.price = price;
                }
            }

            class DeposableProduct extends Product {
                depose() {
                    this.deposed = true;
                }
            }

            const gum = Product.build('껌', 1000);
            console.log(gum);                           // Product {id: 863, name: "껌", price: 1000}

            const clothes = new DeposableProduct(1, '옷', 2000);
            const taxPrice = DeposableProduct.getTaxPrice(clothes);
            console.log(taxPrice);                      // 2200            
        ]]>
        </script>
        <div class="desc">
            <ol>
                <li><span>1~5</span>static 키워드로 정적 메소드 build를 정의한다. 변수 id에는 소수점을 버린 0 ~ 1000의 난수 값을 할당하고 id, name, price를 매개변수로 가진 Product의 인스턴스를 반환한다.</li>
                <li><span>7~8</span>세금을 계산후 반환하는 정적 메소드 getTaxPrice를 정의한다.</li>
                <li><span>11~15</span>Product 클래스의 생성자 함수를 정의한다.<br>(생성자 함수 이름은 constructor로 고정, 매개변수를 정의 할수 있고 하나의 생성자만 정의할 수 있다.)</li>
                <li><span>18~22</span>Product 클래스를 상속하는 DeposableProduct 클래스를 정의한다. 생성자 함수의 prototype 기반 상속과 다르게 클래스로 상속을 하면 정적 메소드도 상속하게 된다.<br>prototype의 상속 ex) const productStorage = new Storage();</li>
                <li><span>24~25</span>변수 gum에 Product 클래스의 정적 메소드 build의 인스턴스를 반환한다. 콘솔 출력으로 매개변수가 적용된 인스턴스를 확인할 수 있다.</li>
                <li><span>27~29</span>DeposableProduct 인스턴스를 생성한다. DeposableProduct 클래스에는 getTaxPrice 메소드가 없지만 상속을 받아서 호출이 가능하다.</li>
            </ol>
        </div>
        
        <div class="content">
            <ul class="bull_list">
                <li>정적 속성도 static, get 키워드로 정의할 수 있다.</li>
            </ul>
        </div>
        <script type="syntaxhighlighter" class="brush: js;">
        <![CDATA[
            class ProductWithCode {
                static get CODE_PREFIX() {
                    return "PRODUCT-"
                }

                constructor(id) {
                    this.id
                    this.code = ProductWithCode.CODE_PREFIX + id;
                }
            }

            const product1 = new ProductWithCode('001');
            console.log(ProductWithCode.CODE_PREFIX);       // PRODUCT-
            console.log(product1.code);                     // PRODUCT-001         
        ]]>
        </script>
        <div class="desc">
            <ol>
                <li><span>1~4</span>ProductWithCode 클래스를 정의하면서 정적 속성 CODE_PREFIX를 정의한다. 클래스 몸통 블록 밖에서 <br>
                    ProductWithCode.CODE_PREFIX = "PRODUCT-"로 정의할 수 있지만 코드의 가독성을 위해선 몸통 안에서 static get 키워드를 통해 정의하는것이 좋다.
                </li>
                <li><span>6~10</span>ProductWithCode 클래스의 생성자 함수를 정의한다. code 속성은 ProductWithCode.CODE_PREFIX + id로 정의하고 있다.</li>
                <li><span>12~14</span>ProductWithCode 클래스의 인스턴스를 생성하고 콘솔로 정적 속성 ProductWithCode.CODE_PREFIX를 출력한다.<br>
                    해당 인스턴스의 code 메소드의 값을 콘솔로 출력한다.
                </li>
            </ol>
        </div>	
    </div>
    
    <div>
        <h2><span>초급 054</span>this 이해하기</h2>
        <div class="content">
            <ul class="bull_list">
                <li><p></p></li>
            </ul>
            <script type="syntaxhighlighter" class="brush: js;">
            <![CDATA[
                
            ]]>
            </script>
        </div>
        <script type="syntaxhighlighter" class="brush: js;">
        <![CDATA[
            
        ]]>
        </script>
        <div class="desc">
            <ol>
                <li><span></span></li>
            </ol>
        </div>	
    </div>
    
    <div>
        <h2><span>초급 055</span>모듈 이해하기</h2>
        <div class="content">
            <ul class="bull_list">
                <li><p></p></li>
            </ul>
            <script type="syntaxhighlighter" class="brush: js;">
            <![CDATA[
                
            ]]>
            </script>
        </div>
        <script type="syntaxhighlighter" class="brush: js;">
        <![CDATA[
            
        ]]>
        </script>
        <div class="desc">
            <ol>
                <li><span></span></li>
            </ol>
        </div>	
    </div>
    
    <div>
        <h2><span>초급 056</span>모듈 시스템 이해하기</h2>
        <div class="content">
            <ul class="bull_list">
                <li><p></p></li>
            </ul>
            <script type="syntaxhighlighter" class="brush: js;">
            <![CDATA[
                
            ]]>
            </script>
        </div>
        <script type="syntaxhighlighter" class="brush: js;">
        <![CDATA[
            
        ]]>
        </script>
        <div class="desc">
            <ol>
                <li><span></span></li>
            </ol>
        </div>	
    </div>
    
    <div>
        <h2><span>초급 057</span>모듈 기본값 정의하고 가져오기</h2>
        <div class="content">
            <ul class="bull_list">
                <li><p></p></li>
            </ul>
            <script type="syntaxhighlighter" class="brush: js;">
            <![CDATA[
                
            ]]>
            </script>
        </div>
        <script type="syntaxhighlighter" class="brush: js;">
        <![CDATA[
            
        ]]>
        </script>
        <div class="desc">
            <ol>
                <li><span></span></li>
            </ol>
        </div>	
    </div>
    
    <div>
        <h2><span>초급 058</span>모듈을 여러 이름으로 내보내고 가져오기</h2>
        <div class="content">
            <ul class="bull_list">
                <li><p></p></li>
            </ul>
            <script type="syntaxhighlighter" class="brush: js;">
            <![CDATA[
                
            ]]>
            </script>
        </div>
        <script type="syntaxhighlighter" class="brush: js;">
        <![CDATA[
            
        ]]>
        </script>
        <div class="desc">
            <ol>
                <li><span></span></li>
            </ol>
        </div>	
    </div>
    
    <div>
        <h2><span>초급 059</span>모듈을 다양한 방식으로 사용하기</h2>
        <div class="content">
            <ul class="bull_list">
                <li><p></p></li>
            </ul>
            <script type="syntaxhighlighter" class="brush: js;">
            <![CDATA[
                
            ]]>
            </script>
        </div>
        <script type="syntaxhighlighter" class="brush: js;">
        <![CDATA[
            
        ]]>
        </script>
        <div class="desc">
            <ol>
                <li><span></span></li>
            </ol>
        </div>	
    </div>
</div>
<!-- //js_ex200 -->
    
</body>
</html>